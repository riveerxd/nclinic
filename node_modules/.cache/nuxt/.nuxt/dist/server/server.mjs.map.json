{"file":"server.mjs","mappings":"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","names":["globalThis","$fetch","create","baseURL","global","nuxtLinkDefaults","componentName","appId","getNuxtAppCtx","id","getContext","asyncContext","NuxtPluginIndicator","registerPluginHooks","nuxtApp","plugin","hooks","addHooks","defineNuxtPlugin","_name","name","Object","assign","setup","callWithNuxt","nuxt","args","fn","nuxtAppCtx","_id","vueApp","runWithContext","callAsync","useNuxtApp","nuxtAppInstance","hasInjectionContext","getCurrentInstance","appContext","app","$nuxt","tryUse","tryUseNuxtApp","Error","useRuntimeConfig","_event","$config","defineGetter","obj","key","val","defineProperty","get","LayoutMetaSymbol","Symbol","PageRouteSymbol","useRouter","$router","useRoute","inject","_route","defineNuxtRouteMiddleware","middleware","URL_QUOTE_RE","navigateTo","to","options","toPath","resolveRouteObject","resolve","href","isExternalHost","hasProtocol","acceptRelative","isExternal","external","protocol","URL","isScriptProtocol","inMiddleware","_processingMiddleware","isProcessingMiddleware","router","ssrContext","fullPath","location2","joinURL","redirect","async","response","callHook","encodedLoc","replace","encodedHeader","url","pathname","search","hash","startsWith","toString","encodeURL","_renderResponse","statusCode","sanitizeStatusCode","redirectCode","body","headers","location","afterEach","final","_scope","stop","isHydrating","Promise","push","withQuery","path","query","NUXT_ERROR_SIGNATURE","useError","toRef","payload","showError","error","nuxtError","createError","error2","value","isNuxtError","createH3Error","configurable","writable","unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU","enforce","head","use","toArray","Array","isArray","_routes","component","import","ROUTE_KEY_PARENTHESES_RE","ROUTE_KEY_SYMBOLS_RE","ROUTE_KEY_NORMAL_RE","generateRouteKey","route","source","meta","r","params","slice","_getHashElementScrollMarginTop","selector","elem","querySelector","Number","parseFloat","getComputedStyle","scrollMarginTop","documentElement","scrollPaddingTop","_calculatePosition","from","savedPosition","defaultHashScrollBehaviour","isPageNavigation","START_LOCATION","matched","every","comp","index","components","default","isChangingPage","el","top","behavior","left","routerOptions","hashMode","scrollBehaviorType","scrollBehavior","hashScrollBehaviour","scrollToTop","hookToWait","_runningTransition","hookOnce","requestAnimationFrame","globalMiddleware","__temp","__restore","validate","__executeAsync","result","fatal","statusMessage","data","namedMiddleware","routerBase","history","createMemoryHistory","routes","startPosition","createRouter","unsub","beforeEach","scrollRestoration","previousRoute","shallowRef","currentRoute","_to","config","globalProperties","initialURL","syncCurrentRoute","hook","enumerable","shallowReactive","named","islandContext","_from","failure","type","redirectedFrom","isReady","resolvedInitialRoute","provide","initialLayout","state","_layout","reactive","isReadonly","layout","middlewareEntries","Set","_middleware","componentMiddleware","entry","add","arg","_preloadManifest","_routeRulesMatcher","toRouteMatcher","createRadixRouter","nitro","routeRules","defu","matchAll","reverse","getRouteRules","appMiddleware","delete","then","err","onError","length","force","injectHead","headSymbol","useHead","input","headCore","defineComponent","render","createElementBlock","clientOnlySymbol","for","inheritAttrs","props","slots","attrs","mounted","vm","_nuxtClientOnly","vnodes","cloneVNode","slot","fallback","placeholder","h","fallbackStr","fallbackTag","placeholderTag","useRequestEvent","event","prerenderRoutes","prerender","paths","appendHeader","map","p","encodeURIComponent","join","definePayloadReducer","reduce","_payloadReducers","_0_siteConfig_tU0SxKrPeVRXWcGu2sOnIfhNDbYiKNfDCvYZhRueG0Q","stack","context","siteConfig","autoKey","pop","unshift","_key","init","TypeError","initialValue","isRef","useState","debug","resolveRefs","nuxtSiteConfig","reducers","toJSON","isShallow","JSON","stringify","isReactive","toRaw","__nuxt_island","useSiteConfig","_priority","useSchemaOrgConfig","scriptAttributes","useSchemaOrg","serverHead","useServerHead","script","nodes","tagPriority","resolveSitePath","pathOrUrl","strict","parseURL","base","withLeadingSlash","origin","withoutTrailingSlash","absolute","siteUrl","endsWith","indexOf","baseWithOrigin","withBase","resolvedUrl","trailingSlash","$url","lastSegment","split","ext","match","fileExtensions","includes","isPathFile","fixedPath","withTrailingSlash","host","fixSlashes","useNitroOrigin","e","siteConfigNitroOrigin","createSitePathResolver","nitroOrigin","nuxtBase","computed","unref","canonical","withSiteUrl","componentNames","pascalName","kebabName","category","credits","generateMeta","resolvedOptions","property","content","withoutQuery","extension","getExtension","toValue","width","height","alt","isInternalRoute","filterIsOgImageOption","separateProps","ignoreKeys","_props","fromEntries","entries","filter","k","forEach","g","String","toUpperCase","setHeadOgImagePrebuilt","createOgImageMeta","src","defaults","useOgImageRuntimeConfig","_input","_ogImagePayload","_query","keys","_ogImageInstances","processTemplateParams","innerHTML","resolveUnrefHeadInput","title","originalName","component2","resolveComponentName","tagPosition","instance","getOgImagePath","pagePath","_options","c","OPTIONAL_PARAM_RE","shouldPrerender","processRoutes","routes2","currentPath","routesToPrerender","test","children","plugins","router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw","reducer","dependsOn","defineWebSite","inLanguage","currentLocale","description","defineWebPage","identity","identityType","identityPayload","twitter","sameAs","_resolver","camelCase","maybeAddIdentitySchemaOrg","resolvePath","resolveUrl","schemaOrg","defaultLocale","templateParams","SchemaOrgUnheadPlugin","minify","initPlugin","ctx","robots","rule","TemplateParamsPlugin","ctx2","hasPrimaryPayload","tags","some","tag","overrides","parse","_d","Boolean","matchedRules","runtimeConfig","withoutBase","combinedRules","ogImage","ogImageInstances","e2","dispose","_nitro","splice","layouts","defineAsyncComponent","m","LayoutLoader","layoutProps","nuxtLayoutProps","__nuxt_component_0","injectedRoute","useVueRouterRoute","layout2","layoutRef","expose","done","deferHydration","lastLayout","transitionProps","layoutTransition","previouslyRenderedLayout","Suspense","suspensible","onResolve","nextTick","LayoutProvider","mergeProps","ref","shouldProvide","isRenderingNewLayout","hasTransition","Function","required","isCurrent","vueRouterRoute","reactiveChildRoute","RouteProvider","vnode","vnodeRef","renderKey","trackRootNodes","previousKey","defineRouteProvider","__nuxt_component_1","transition","keepalive","pageKey","pageRef","RouterView","routeProps","normalizeSlot","Component","slotContent","Fragment","_","_push","_parent","_scopeId","_createVNode","_component_NuxtPage","_error","__props","line","text","trim","internal","i","is404","message","_Error404","_Error","ErrorTemplate","_ssrRenderComponent","_unref","_mergeProps","_attrs","IslandRenderer","SingleRenderer","callHookWith","abortRender","onErrorCaptured","target","info","catch","hookError","onServerPrefetch","ErrorComponent","createApp","RootComponent","hydratingCount","effectScope","versions","vue","version","once","_errors","static","active","getCurrentScope","run","called","_asyncDataPromises","_asyncData","_payloadRevivers","serverRendered","public","createHooks","contextCaller","$name","createNuxtApp","resolvedPlugins","unresolvedPlugins","parallels","promiseDepth","executePlugin","unresolvedPluginsForThisPlugin","has","promise","applyPlugin","all","unexecutedPlugin","size","parallel","env","islands","applyPlugins","entry$1"],"sources":["../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Ffetch.mjs","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Fglobal-polyfills.mjs","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Fnuxt.config.mjs","../../../../../nuxt/dist/app/nuxt.js","../../../../../nuxt/dist/app/components/injections.js","../../../../../nuxt/dist/app/composables/router.js","../../../../../nuxt/dist/app/composables/error.js","../../../../../nuxt/dist/head/runtime/plugins/unhead.js","../../../../../nuxt/dist/pages/runtime/utils.js","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Froutes.mjs","../../../../../nuxt/dist/app/components/utils.js","../../../../../nuxt/dist/pages/runtime/router.options.js","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Frouter.options.mjs","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Fmiddleware.mjs","../../../../../nuxt/dist/pages/runtime/validate.js","../../../../../nuxt/dist/app/middleware/manifest-route-rule.js","../../../../../nuxt/dist/pages/runtime/plugins/router.js","../../../../../nuxt/dist/app/composables/manifest.js","../../../../../nuxt/dist/head/runtime/composables.js","../../../../../nuxt/dist/app/components/server-placeholder.js","../../../../../nuxt/dist/app/components/client-only.js","../../../../../nuxt/dist/app/composables/ssr.js","../../../../../nuxt/dist/app/utils.js","../../../../../nuxt/dist/app/composables/payload.js","../../../../../nuxt-site-config/dist/runtime/app/plugins/0.siteConfig.js","../../../../../nuxt/dist/app/composables/state.js","../../../../../nuxt/dist/app/plugins/revive-payload.server.js","../../../../../nuxt-site-config/dist/runtime/app/composables/useSiteConfig.js","../../../../../nuxt-schema-org/dist/runtime/app/utils/config.js","../../../../../nuxt-schema-org/dist/runtime/app/composables/useSchemaOrg.js","../../../../../site-config-stack/dist/urls.mjs","../../../../../nuxt-site-config/dist/runtime/app/composables/useNitroOrigin.js","../../../../../nuxt-site-config/dist/runtime/app/composables/utils.js","../../../../../nuxt-schema-org/dist/runtime/app/plugins/defaults.js","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Fnuxt-og-image%2Fcomponents.mjs","../../../../../nuxt-og-image/dist/runtime/shared.js","../../../../../nuxt-og-image/dist/runtime/app/utils.js","../../../../../nuxt/dist/pages/runtime/plugins/prerender.server.js","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Fplugins.server.mjs","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Fcomponents.plugin.mjs","../../../../../nuxt-schema-org/dist/runtime/app/utils/shared.js","../../../../../nuxt-schema-org/dist/runtime/app/plugins/init.js","../../../../../@nuxtjs/robots/dist/runtime/app/plugins/robot-meta.server.js","../../../../../nuxt-og-image/dist/runtime/app/plugins/og-image-canonical-urls.server.js","../../../../../nuxt-og-image/dist/runtime/app/utils/plugins.js","../../../../../nuxt-og-image/dist/runtime/app/plugins/route-rule-og-image.server.js","../../../../../../virtual:nuxt:%2Fhome%2Friver%2FProjects%2Foc%2Fnclinic.cz%2Fnode_modules%2F.cache%2Fnuxt%2F.nuxt%2Flayouts.mjs","../../../../../nuxt/dist/app/components/nuxt-layout.js","../../../../../nuxt/dist/app/components/route-provider.js","../../../../../nuxt/dist/pages/runtime/page.js","../../../../../../app/app.vue","../../../../../nuxt/dist/app/components/nuxt-error-page.vue","../../../../../nuxt/dist/app/components/nuxt-root.vue","../../../../../nuxt/dist/app/entry.js"],"sourcesContent":["import { $fetch } from 'ofetch'\nimport { baseURL } from '#internal/nuxt/paths'\nif (!globalThis.$fetch) {\n  globalThis.$fetch = $fetch.create({\n    baseURL: baseURL()\n  })\n}","\nif (!(\"global\" in globalThis)) {\n  globalThis.global = globalThis;\n}","export const appHead = {\"meta\":[{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},{\"charset\":\"utf-8\"},{\"name\":\"description\",\"content\":\"NClinic - Zubní klinika Praha 4 Kamýk se specialistou MUDr. Jamal Karra DDS, MS, CSc. pro čelistní a obličejovou chirurgii. Moderní stomatologie, dentální hygiena, implantologie. Zárubova 498/31. ☎ +420 703 622 644. Ordinujeme Po-Pá 8:00-16:00.\"},{\"name\":\"keywords\",\"content\":\"NClinic, zubní klinika Praha 4, MUDr. Jamal Karra, čelistní chirurgie Praha, obličejová chirurgie, stomatologie Kamýk, dentální hygiena, zubní implantáty, ústní chirurgie, zubní lékař Praha 4, Zárubova, estetická stomatologie, parodontologie, endodoncie, protetika, záchovná stomatologie, dentista Kamýk\"},{\"name\":\"author\",\"content\":\"N Clinic s.r.o.\"},{\"name\":\"robots\",\"content\":\"index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1\"},{\"name\":\"googlebot\",\"content\":\"index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1\"},{\"name\":\"bingbot\",\"content\":\"index, follow, max-image-preview:large, max-snippet:-1, max-video-preview:-1\"},{\"property\":\"og:type\",\"content\":\"website\"},{\"property\":\"og:site_name\",\"content\":\"NClinic\"},{\"property\":\"og:title\",\"content\":\"NClinic Praha 4 | MUDr. Jamal Karra | Čelistní Chirurgie\"},{\"property\":\"og:description\",\"content\":\"Moderní zubní klinika v Praze 4 se specialistou na čelistní a obličejovou chirurgii. Dentální hygiena, implantologie, stomatologie. Zárubova 498/31, Kamýk.\"},{\"property\":\"og:url\",\"content\":\"https://www.nclinic.cz/\"},{\"property\":\"og:image\",\"content\":\"https://www.nclinic.cz/images/preview.png\"},{\"property\":\"og:image:width\",\"content\":\"1200\"},{\"property\":\"og:image:height\",\"content\":\"630\"},{\"property\":\"og:image:alt\",\"content\":\"NClinic - Moderní zubní klinika Praha 4\"},{\"property\":\"og:locale\",\"content\":\"cs_CZ\"},{\"name\":\"twitter:card\",\"content\":\"summary_large_image\"},{\"name\":\"twitter:title\",\"content\":\"NClinic Praha 4 | MUDr. Jamal Karra | Čelistní Chirurgie\"},{\"name\":\"twitter:description\",\"content\":\"Moderní zubní klinika se specialistou na čelistní chirurgii. Dentální hygiena, implantologie. ☎ +420 703 622 644\"},{\"name\":\"twitter:image\",\"content\":\"https://www.nclinic.cz/images/preview.png\"},{\"name\":\"twitter:image:alt\",\"content\":\"NClinic - Moderní zubní klinika Praha 4\"},{\"name\":\"geo.region\",\"content\":\"CZ-PR\"},{\"name\":\"geo.placename\",\"content\":\"Praha 4, Kamýk\"},{\"name\":\"geo.position\",\"content\":\"50.0195;14.4395\"},{\"name\":\"ICBM\",\"content\":\"50.0195, 14.4395\"},{\"name\":\"contact\",\"content\":\"sestra@nclinic.cz\"},{\"name\":\"telephone\",\"content\":\"+420703622644\"},{\"name\":\"business:contact_data:street_address\",\"content\":\"Zárubova 498/31\"},{\"name\":\"business:contact_data:locality\",\"content\":\"Praha 4, Kamýk\"},{\"name\":\"business:contact_data:postal_code\",\"content\":\"142 00\"},{\"name\":\"business:contact_data:country_name\",\"content\":\"Česká republika\"}],\"link\":[{\"rel\":\"canonical\",\"href\":\"https://www.nclinic.cz/\"},{\"rel\":\"icon\",\"type\":\"image/x-icon\",\"href\":\"/favicon.ico\"},{\"rel\":\"preconnect\",\"href\":\"https://fonts.googleapis.com\"},{\"rel\":\"preconnect\",\"href\":\"https://fonts.gstatic.com\",\"crossorigin\":\"anonymous\"},{\"rel\":\"preload\",\"as\":\"style\",\"href\":\"https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap&subset=latin-ext\"},{\"rel\":\"stylesheet\",\"href\":\"https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap&subset=latin-ext\"},{\"rel\":\"preconnect\",\"href\":\"https://maps.google.com\"},{\"rel\":\"dns-prefetch\",\"href\":\"https://maps.googleapis.com\"}],\"style\":[],\"script\":[{\"type\":\"application/ld+json\",\"innerHTML\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":[\\\"Dentist\\\",\\\"MedicalOrganization\\\",\\\"LocalBusiness\\\"],\\\"@id\\\":\\\"https://www.nclinic.cz/#organization\\\",\\\"name\\\":\\\"NClinic\\\",\\\"alternateName\\\":\\\"N Clinic s.r.o.\\\",\\\"legalName\\\":\\\"N Clinic s.r.o.\\\",\\\"url\\\":\\\"https://www.nclinic.cz\\\",\\\"logo\\\":\\\"https://www.nclinic.cz/logo.png\\\",\\\"image\\\":\\\"https://www.nclinic.cz/images/preview.png\\\",\\\"description\\\":\\\"Moderní zubní klinika v Praze 4 Kamýk specializující se na čelistní a obličejovou chirurgii, dentální hygienu a komplexní stomatologickou péči.\\\",\\\"slogan\\\":\\\"Moderní péče o váš úsměv, špičkové technologie a lidský přístup\\\",\\\"telephone\\\":\\\"+420703622644\\\",\\\"email\\\":\\\"sestra@nclinic.cz\\\",\\\"priceRange\\\":\\\"$$\\\",\\\"currenciesAccepted\\\":\\\"CZK\\\",\\\"paymentAccepted\\\":\\\"Cash, Credit Card\\\",\\\"address\\\":{\\\"@type\\\":\\\"PostalAddress\\\",\\\"streetAddress\\\":\\\"Zárubova 498/31\\\",\\\"addressLocality\\\":\\\"Praha 4\\\",\\\"addressRegion\\\":\\\"Praha\\\",\\\"postalCode\\\":\\\"142 00\\\",\\\"addressCountry\\\":\\\"CZ\\\"},\\\"areaServed\\\":{\\\"@type\\\":\\\"City\\\",\\\"name\\\":\\\"Praha\\\"},\\\"geo\\\":{\\\"@type\\\":\\\"GeoCoordinates\\\",\\\"latitude\\\":50.0195,\\\"longitude\\\":14.4395},\\\"openingHoursSpecification\\\":[{\\\"@type\\\":\\\"OpeningHoursSpecification\\\",\\\"dayOfWeek\\\":[\\\"Monday\\\",\\\"Tuesday\\\",\\\"Wednesday\\\",\\\"Thursday\\\",\\\"Friday\\\"],\\\"opens\\\":\\\"08:00\\\",\\\"closes\\\":\\\"12:00\\\"},{\\\"@type\\\":\\\"OpeningHoursSpecification\\\",\\\"dayOfWeek\\\":[\\\"Monday\\\",\\\"Tuesday\\\",\\\"Wednesday\\\",\\\"Thursday\\\",\\\"Friday\\\"],\\\"opens\\\":\\\"12:30\\\",\\\"closes\\\":\\\"16:00\\\"}],\\\"medicalSpecialty\\\":[\\\"Dentistry\\\",\\\"OralSurgery\\\",\\\"MaxillofacialSurgery\\\"],\\\"employee\\\":{\\\"@type\\\":\\\"Physician\\\",\\\"@id\\\":\\\"https://www.nclinic.cz/#doctor-karra\\\",\\\"name\\\":\\\"MUDr. Jamal Karra DDS, MS, CSc.\\\",\\\"jobTitle\\\":\\\"Zubní lékař - specialista\\\",\\\"medicalSpecialty\\\":[\\\"OralSurgery\\\",\\\"MaxillofacialSurgery\\\"],\\\"description\\\":\\\"Specialista v oboru ústní, čelistní a obličejové chirurgie\\\"},\\\"hasOfferCatalog\\\":{\\\"@type\\\":\\\"OfferCatalog\\\",\\\"name\\\":\\\"Stomatologické služby\\\",\\\"itemListElement\\\":[{\\\"@type\\\":\\\"Offer\\\",\\\"itemOffered\\\":{\\\"@type\\\":\\\"MedicalProcedure\\\",\\\"name\\\":\\\"Dentální hygiena\\\",\\\"description\\\":\\\"Profesionální dentální hygiena a prevence\\\"}},{\\\"@type\\\":\\\"Offer\\\",\\\"itemOffered\\\":{\\\"@type\\\":\\\"MedicalProcedure\\\",\\\"name\\\":\\\"Záchovná stomatologie\\\",\\\"description\\\":\\\"Fotokompozitní výplně a ošetření zubů\\\"}},{\\\"@type\\\":\\\"Offer\\\",\\\"itemOffered\\\":{\\\"@type\\\":\\\"MedicalProcedure\\\",\\\"name\\\":\\\"Endodoncie\\\",\\\"description\\\":\\\"Endodontické ošetření kořenových kanálků\\\"}},{\\\"@type\\\":\\\"Offer\\\",\\\"itemOffered\\\":{\\\"@type\\\":\\\"MedicalProcedure\\\",\\\"name\\\":\\\"Protetika\\\",\\\"description\\\":\\\"Korunky, můstky a protetické práce\\\"}},{\\\"@type\\\":\\\"Offer\\\",\\\"itemOffered\\\":{\\\"@type\\\":\\\"MedicalProcedure\\\",\\\"name\\\":\\\"Chirurgie\\\",\\\"description\\\":\\\"Ústní, čelistní a obličejová chirurgie\\\"}}]},\\\"hasMap\\\":\\\"https://maps.google.com/?q=Zárubova+498/31,+Praha+4\\\",\\\"aggregateRating\\\":{\\\"@type\\\":\\\"AggregateRating\\\",\\\"ratingValue\\\":\\\"5.0\\\",\\\"bestRating\\\":\\\"5\\\",\\\"worstRating\\\":\\\"1\\\",\\\"reviewCount\\\":\\\"1\\\"},\\\"sameAs\\\":[]}\"},{\"type\":\"application/ld+json\",\"innerHTML\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"Physician\\\",\\\"@id\\\":\\\"https://www.nclinic.cz/#doctor-karra\\\",\\\"name\\\":\\\"MUDr. Jamal Karra DDS, MS, CSc.\\\",\\\"honorificPrefix\\\":\\\"MUDr.\\\",\\\"honorificSuffix\\\":\\\"DDS, MS, CSc.\\\",\\\"jobTitle\\\":\\\"Zubní lékař - specialista\\\",\\\"medicalSpecialty\\\":[\\\"OralSurgery\\\",\\\"MaxillofacialSurgery\\\"],\\\"worksFor\\\":{\\\"@id\\\":\\\"https://www.nclinic.cz/#organization\\\"},\\\"description\\\":\\\"Specialista v oboru ústní, čelistní a obličejové chirurgie s dlouholetou praxí\\\"}\"},{\"type\":\"application/ld+json\",\"innerHTML\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"WebSite\\\",\\\"@id\\\":\\\"https://www.nclinic.cz/#website\\\",\\\"url\\\":\\\"https://www.nclinic.cz\\\",\\\"name\\\":\\\"NClinic\\\",\\\"description\\\":\\\"Moderní zubní klinika Praha 4\\\",\\\"publisher\\\":{\\\"@id\\\":\\\"https://www.nclinic.cz/#organization\\\"},\\\"inLanguage\\\":\\\"cs-CZ\\\"}\"},{\"type\":\"application/ld+json\",\"innerHTML\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"BreadcrumbList\\\",\\\"itemListElement\\\":[{\\\"@type\\\":\\\"ListItem\\\",\\\"position\\\":1,\\\"name\\\":\\\"Domů\\\",\\\"item\\\":\\\"https://www.nclinic.cz/\\\"}]}\"},{\"type\":\"application/ld+json\",\"innerHTML\":\"{\\\"@context\\\":\\\"https://schema.org\\\",\\\"@type\\\":\\\"FAQPage\\\",\\\"mainEntity\\\":[{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"Kde se nachází NClinic?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"NClinic se nachází na adrese Zárubova 498/31, Praha 4 - Kamýk, 142 00. Jsme snadno dostupní MHD i autem.\\\"}},{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"Jaká je ordinační doba?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"Ordinujeme Po-Pá od 8:00 do 12:00 a od 12:30 do 16:00. Objednání na tel.: +420 703 622 644 nebo email: sestra@nclinic.cz\\\"}},{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"Jaké služby poskytujete?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"Poskytujeme komplexní stomatologickou péči včetně dentální hygieny, záchovné stomatologie, endodoncie, protetiky a ústní, čelistní a obličejové chirurgie.\\\"}},{\\\"@type\\\":\\\"Question\\\",\\\"name\\\":\\\"Kdo je váš zubní lékař?\\\",\\\"acceptedAnswer\\\":{\\\"@type\\\":\\\"Answer\\\",\\\"text\\\":\\\"Naším specialistou je MUDr. Jamal Karra DDS, MS, CSc., odborník v oblasti ústní, čelistní a obličejové chirurgie s dlouholetou praxí.\\\"}}]}\"}],\"noscript\":[],\"htmlAttrs\":{\"lang\":\"cs\"},\"charset\":\"utf-8\",\"viewport\":\"width=device-width, initial-scale=1\",\"title\":\"NClinic Praha 4 | Moderní Zubní Klinika Kamýk | MUDr. Jamal Karra | Čelistní Chirurgie\"}\n\nexport const appBaseURL = \"/\"\n\nexport const appBuildAssetsDir = \"/_nuxt/\"\n\nexport const appCdnURL = \"\"\n\nexport const appLayoutTransition = false\n\nexport const appPageTransition = false\n\nexport const appViewTransition = false\n\nexport const appKeepalive = false\n\nexport const appRootId = \"__nuxt\"\n\nexport const appRootTag = \"div\"\n\nexport const appRootAttrs = {\"id\":\"__nuxt\"}\n\nexport const appTeleportTag = \"div\"\n\nexport const appTeleportId = \"teleports\"\n\nexport const appTeleportAttrs = {\"id\":\"teleports\"}\n\nexport const appSpaLoaderTag = \"div\"\n\nexport const appSpaLoaderAttrs = {\"id\":\"__nuxt-loader\"}\n\nexport const renderJsonPayloads = true\n\nexport const componentIslands = true\n\nexport const payloadExtraction = false\n\nexport const cookieStore = true\n\nexport const appManifest = true\n\nexport const remoteComponentIslands = false\n\nexport const selectiveClient = false\n\nexport const devPagesDir = null\n\nexport const devRootDir = null\n\nexport const devLogs = false\n\nexport const nuxtLinkDefaults = {\"componentName\":\"NuxtLink\",\"prefetch\":true,\"prefetchOn\":{\"visibility\":true}}\n\nexport const asyncDataDefaults = {\"deep\":false}\n\nexport const fetchDefaults = {}\n\nexport const vueAppRootContainer = '#__nuxt'\n\nexport const viewTransition = false\n\nexport const appId = \"nuxt-app\"\n\nexport const outdatedBuildInterval = 3600000\n\nexport const multiApp = false\n\nexport const chunkErrorEvent = \"vite:preloadError\"\n\nexport const crawlLinks = true\n\nexport const spaLoadingTemplateOutside = true\n\nexport const purgeCachedData = true\n\nexport const granularCachedData = true\n\nexport const pendingWhenIdle = false\n\nexport const alwaysRunFetchOnKeyChange = false","import { effectScope, getCurrentInstance, getCurrentScope, hasInjectionContext, reactive, shallowReactive } from \"vue\";\nimport { createHooks } from \"hookable\";\nimport { getContext } from \"unctx\";\nimport { appId, chunkErrorEvent, multiApp } from \"#build/nuxt.config.mjs\";\nexport function getNuxtAppCtx(id = appId || \"nuxt-app\") {\n  return getContext(id, {\n    asyncContext: !!__NUXT_ASYNC_CONTEXT__ && import.meta.server\n  });\n}\nexport const NuxtPluginIndicator = \"__nuxt_plugin\";\nexport function createNuxtApp(options) {\n  let hydratingCount = 0;\n  const nuxtApp = {\n    _id: options.id || appId || \"nuxt-app\",\n    _scope: effectScope(),\n    provide: void 0,\n    versions: {\n      get nuxt() {\n        return __NUXT_VERSION__;\n      },\n      get vue() {\n        return nuxtApp.vueApp.version;\n      }\n    },\n    payload: shallowReactive({\n      ...options.ssrContext?.payload || {},\n      data: shallowReactive({}),\n      state: reactive({}),\n      once: /* @__PURE__ */ new Set(),\n      _errors: shallowReactive({})\n    }),\n    static: {\n      data: {}\n    },\n    runWithContext(fn) {\n      if (nuxtApp._scope.active && !getCurrentScope()) {\n        return nuxtApp._scope.run(() => callWithNuxt(nuxtApp, fn));\n      }\n      return callWithNuxt(nuxtApp, fn);\n    },\n    isHydrating: import.meta.client,\n    deferHydration() {\n      if (!nuxtApp.isHydrating) {\n        return () => {\n        };\n      }\n      hydratingCount++;\n      let called = false;\n      return () => {\n        if (called) {\n          return;\n        }\n        called = true;\n        hydratingCount--;\n        if (hydratingCount === 0) {\n          nuxtApp.isHydrating = false;\n          return nuxtApp.callHook(\"app:suspense:resolve\");\n        }\n      };\n    },\n    _asyncDataPromises: {},\n    _asyncData: shallowReactive({}),\n    _payloadRevivers: {},\n    ...options\n  };\n  if (import.meta.server) {\n    nuxtApp.payload.serverRendered = true;\n  }\n  if (import.meta.server && nuxtApp.ssrContext) {\n    nuxtApp.payload.path = nuxtApp.ssrContext.url;\n    nuxtApp.ssrContext.nuxt = nuxtApp;\n    nuxtApp.ssrContext.payload = nuxtApp.payload;\n    nuxtApp.ssrContext.config = {\n      public: nuxtApp.ssrContext.runtimeConfig.public,\n      app: nuxtApp.ssrContext.runtimeConfig.app\n    };\n  }\n  if (import.meta.client) {\n    const __NUXT__ = multiApp ? window.__NUXT__?.[nuxtApp._id] : window.__NUXT__;\n    if (__NUXT__) {\n      for (const key in __NUXT__) {\n        switch (key) {\n          case \"data\":\n          case \"state\":\n          case \"_errors\":\n            Object.assign(nuxtApp.payload[key], __NUXT__[key]);\n            break;\n          default:\n            nuxtApp.payload[key] = __NUXT__[key];\n        }\n      }\n    }\n  }\n  nuxtApp.hooks = createHooks();\n  nuxtApp.hook = nuxtApp.hooks.hook;\n  if (import.meta.server) {\n    const contextCaller = async function(hooks, args) {\n      for (const hook of hooks) {\n        await nuxtApp.runWithContext(() => hook(...args));\n      }\n    };\n    nuxtApp.hooks.callHook = (name, ...args) => nuxtApp.hooks.callHookWith(contextCaller, name, ...args);\n  }\n  nuxtApp.callHook = nuxtApp.hooks.callHook;\n  nuxtApp.provide = (name, value) => {\n    const $name = \"$\" + name;\n    defineGetter(nuxtApp, $name, value);\n    defineGetter(nuxtApp.vueApp.config.globalProperties, $name, value);\n  };\n  defineGetter(nuxtApp.vueApp, \"$nuxt\", nuxtApp);\n  defineGetter(nuxtApp.vueApp.config.globalProperties, \"$nuxt\", nuxtApp);\n  if (import.meta.client) {\n    if (chunkErrorEvent) {\n      window.addEventListener(chunkErrorEvent, (event) => {\n        nuxtApp.callHook(\"app:chunkError\", { error: event.payload });\n        if (event.payload.message.includes(\"Unable to preload CSS\")) {\n          event.preventDefault();\n        }\n      });\n    }\n    window.useNuxtApp ||= useNuxtApp;\n    const unreg = nuxtApp.hook(\"app:error\", (...args) => {\n      console.error(\"[nuxt] error caught during app initialization\", ...args);\n    });\n    nuxtApp.hook(\"app:mounted\", unreg);\n  }\n  const runtimeConfig = import.meta.server ? options.ssrContext.runtimeConfig : nuxtApp.payload.config;\n  nuxtApp.provide(\"config\", import.meta.client && import.meta.dev ? wrappedConfig(runtimeConfig) : runtimeConfig);\n  return nuxtApp;\n}\nexport function registerPluginHooks(nuxtApp, plugin) {\n  if (plugin.hooks) {\n    nuxtApp.hooks.addHooks(plugin.hooks);\n  }\n}\nexport async function applyPlugin(nuxtApp, plugin) {\n  if (typeof plugin === \"function\") {\n    const { provide } = await nuxtApp.runWithContext(() => plugin(nuxtApp)) || {};\n    if (provide && typeof provide === \"object\") {\n      for (const key in provide) {\n        nuxtApp.provide(key, provide[key]);\n      }\n    }\n  }\n}\nexport async function applyPlugins(nuxtApp, plugins) {\n  const resolvedPlugins = /* @__PURE__ */ new Set();\n  const unresolvedPlugins = [];\n  const parallels = [];\n  let error = void 0;\n  let promiseDepth = 0;\n  async function executePlugin(plugin) {\n    const unresolvedPluginsForThisPlugin = plugin.dependsOn?.filter((name) => plugins.some((p) => p._name === name) && !resolvedPlugins.has(name)) ?? [];\n    if (unresolvedPluginsForThisPlugin.length > 0) {\n      unresolvedPlugins.push([new Set(unresolvedPluginsForThisPlugin), plugin]);\n    } else {\n      const promise = applyPlugin(nuxtApp, plugin).then(async () => {\n        if (plugin._name) {\n          resolvedPlugins.add(plugin._name);\n          await Promise.all(unresolvedPlugins.map(async ([dependsOn, unexecutedPlugin]) => {\n            if (dependsOn.has(plugin._name)) {\n              dependsOn.delete(plugin._name);\n              if (dependsOn.size === 0) {\n                promiseDepth++;\n                await executePlugin(unexecutedPlugin);\n              }\n            }\n          }));\n        }\n      }).catch((e) => {\n        if (!plugin.parallel && !nuxtApp.payload.error) {\n          throw e;\n        }\n        error ||= e;\n      });\n      if (plugin.parallel) {\n        parallels.push(promise);\n      } else {\n        await promise;\n      }\n    }\n  }\n  for (const plugin of plugins) {\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {\n      continue;\n    }\n    registerPluginHooks(nuxtApp, plugin);\n  }\n  for (const plugin of plugins) {\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext && plugin.env?.islands === false) {\n      continue;\n    }\n    await executePlugin(plugin);\n  }\n  await Promise.all(parallels);\n  if (promiseDepth) {\n    for (let i = 0; i < promiseDepth; i++) {\n      await Promise.all(parallels);\n    }\n  }\n  if (error) {\n    throw nuxtApp.payload.error || error;\n  }\n}\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtPlugin(plugin) {\n  if (typeof plugin === \"function\") {\n    return plugin;\n  }\n  const _name = plugin._name || plugin.name;\n  delete plugin.name;\n  return Object.assign(plugin.setup || (() => {\n  }), plugin, { [NuxtPluginIndicator]: true, _name });\n}\nexport const definePayloadPlugin = defineNuxtPlugin;\nexport function isNuxtPlugin(plugin) {\n  return typeof plugin === \"function\" && NuxtPluginIndicator in plugin;\n}\nexport function callWithNuxt(nuxt, setup, args) {\n  const fn = () => args ? setup(...args) : setup();\n  const nuxtAppCtx = getNuxtAppCtx(nuxt._id);\n  if (import.meta.server) {\n    return nuxt.vueApp.runWithContext(() => nuxtAppCtx.callAsync(nuxt, fn));\n  } else {\n    nuxtAppCtx.set(nuxt);\n    return nuxt.vueApp.runWithContext(fn);\n  }\n}\nexport function tryUseNuxtApp(id) {\n  let nuxtAppInstance;\n  if (hasInjectionContext()) {\n    nuxtAppInstance = getCurrentInstance()?.appContext.app.$nuxt;\n  }\n  nuxtAppInstance ||= getNuxtAppCtx(id).tryUse();\n  return nuxtAppInstance || null;\n}\nexport function useNuxtApp(id) {\n  const nuxtAppInstance = tryUseNuxtApp(id);\n  if (!nuxtAppInstance) {\n    if (import.meta.dev) {\n      throw new Error(\"[nuxt] A composable that requires access to the Nuxt instance was called outside of a plugin, Nuxt hook, Nuxt middleware, or Vue setup function. This is probably not a Nuxt bug. Find out more at `https://nuxt.com/docs/guide/concepts/auto-imports#vue-and-nuxt-composables`.\");\n    } else {\n      throw new Error(\"[nuxt] instance unavailable\");\n    }\n  }\n  return nuxtAppInstance;\n}\n// @__NO_SIDE_EFFECTS__\nexport function useRuntimeConfig(_event) {\n  return useNuxtApp().$config;\n}\nfunction defineGetter(obj, key, val) {\n  Object.defineProperty(obj, key, { get: () => val });\n}\nexport function defineAppConfig(config) {\n  return config;\n}\nconst loggedKeys = /* @__PURE__ */ new Set();\nfunction wrappedConfig(runtimeConfig) {\n  if (!import.meta.dev || import.meta.server) {\n    return runtimeConfig;\n  }\n  const keys = Object.keys(runtimeConfig).map((key) => `\\`${key}\\``);\n  const lastKey = keys.pop();\n  return new Proxy(runtimeConfig, {\n    get(target, p, receiver) {\n      if (typeof p === \"string\" && p !== \"public\" && !(p in target) && !p.startsWith(\"__v\")) {\n        if (!loggedKeys.has(p)) {\n          loggedKeys.add(p);\n          console.warn(`[nuxt] Could not access \\`${p}\\`. The only available runtime config keys on the client side are ${keys.join(\", \")} and ${lastKey}. See https://nuxt.com/docs/guide/going-further/runtime-config for more information.`);\n        }\n      }\n      return Reflect.get(target, p, receiver);\n    }\n  });\n}\n","export const LayoutMetaSymbol = Symbol(\"layout-meta\");\nexport const PageRouteSymbol = Symbol(\"route\");\n","import { getCurrentInstance, hasInjectionContext, inject, onScopeDispose } from \"vue\";\nimport { sanitizeStatusCode } from \"h3\";\nimport { hasProtocol, isScriptProtocol, joinURL, parseQuery, parseURL, withQuery } from \"ufo\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { PageRouteSymbol } from \"../components/injections.js\";\nimport { createError, showError } from \"./error.js\";\nexport const useRouter = () => {\n  return useNuxtApp()?.$router;\n};\nexport const useRoute = () => {\n  if (import.meta.dev && !getCurrentInstance() && isProcessingMiddleware()) {\n    console.warn(\"[nuxt] Calling `useRoute` within middleware may lead to misleading results. Instead, use the (to, from) arguments passed to the middleware to access the new and old routes.\");\n  }\n  if (hasInjectionContext()) {\n    return inject(PageRouteSymbol, useNuxtApp()._route);\n  }\n  return useNuxtApp()._route;\n};\nexport const onBeforeRouteLeave = (guard) => {\n  const unsubscribe = useRouter().beforeEach((to, from, next) => {\n    if (to === from) {\n      return;\n    }\n    return guard(to, from, next);\n  });\n  onScopeDispose(unsubscribe);\n};\nexport const onBeforeRouteUpdate = (guard) => {\n  const unsubscribe = useRouter().beforeEach(guard);\n  onScopeDispose(unsubscribe);\n};\n// @__NO_SIDE_EFFECTS__\nexport function defineNuxtRouteMiddleware(middleware) {\n  return middleware;\n}\nexport const addRouteMiddleware = (name, middleware, options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const global = options.global || typeof name !== \"string\";\n  const mw = typeof name !== \"string\" ? name : middleware;\n  if (!mw) {\n    console.warn(\"[nuxt] No route middleware passed to `addRouteMiddleware`.\", name);\n    return;\n  }\n  if (global) {\n    nuxtApp._middleware.global.push(mw);\n  } else {\n    nuxtApp._middleware.named[name] = mw;\n  }\n};\nconst isProcessingMiddleware = () => {\n  try {\n    if (useNuxtApp()._processingMiddleware) {\n      return true;\n    }\n  } catch {\n    return false;\n  }\n  return false;\n};\nconst URL_QUOTE_RE = /\"/g;\nexport const navigateTo = (to, options) => {\n  to ||= \"/\";\n  const toPath = typeof to === \"string\" ? to : \"path\" in to ? resolveRouteObject(to) : useRouter().resolve(to).href;\n  if (import.meta.client && options?.open) {\n    const { target = \"_blank\", windowFeatures = {} } = options.open;\n    const features = Object.entries(windowFeatures).filter(([_, value]) => value !== void 0).map(([feature, value]) => `${feature.toLowerCase()}=${value}`).join(\", \");\n    open(toPath, target, features);\n    return Promise.resolve();\n  }\n  const isExternalHost = hasProtocol(toPath, { acceptRelative: true });\n  const isExternal = options?.external || isExternalHost;\n  if (isExternal) {\n    if (!options?.external) {\n      throw new Error(\"Navigating to an external URL is not allowed by default. Use `navigateTo(url, { external: true })`.\");\n    }\n    const { protocol } = new URL(toPath, import.meta.client ? window.location.href : \"http://localhost\");\n    if (protocol && isScriptProtocol(protocol)) {\n      throw new Error(`Cannot navigate to a URL with '${protocol}' protocol.`);\n    }\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (import.meta.client && !isExternal && inMiddleware) {\n    if (options?.replace) {\n      if (typeof to === \"string\") {\n        const { pathname, search, hash } = parseURL(to);\n        return {\n          path: pathname,\n          ...search && { query: parseQuery(search) },\n          ...hash && { hash },\n          replace: true\n        };\n      }\n      return { ...to, replace: true };\n    }\n    return to;\n  }\n  const router = useRouter();\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (nuxtApp.ssrContext) {\n      const fullPath = typeof to === \"string\" || isExternal ? toPath : router.resolve(to).fullPath || \"/\";\n      const location2 = isExternal ? toPath : joinURL(useRuntimeConfig().app.baseURL, fullPath);\n      const redirect = async function(response) {\n        await nuxtApp.callHook(\"app:redirected\");\n        const encodedLoc = location2.replace(URL_QUOTE_RE, \"%22\");\n        const encodedHeader = encodeURL(location2, isExternalHost);\n        nuxtApp.ssrContext._renderResponse = {\n          statusCode: sanitizeStatusCode(options?.redirectCode || 302, 302),\n          body: `<!DOCTYPE html><html><head><meta http-equiv=\"refresh\" content=\"0; url=${encodedLoc}\"></head></html>`,\n          headers: { location: encodedHeader }\n        };\n        return response;\n      };\n      if (!isExternal && inMiddleware) {\n        router.afterEach((final) => final.fullPath === fullPath ? redirect(false) : void 0);\n        return to;\n      }\n      return redirect(!inMiddleware ? void 0 : (\n        /* abort route navigation */\n        false\n      ));\n    }\n  }\n  if (isExternal) {\n    nuxtApp._scope.stop();\n    if (options?.replace) {\n      location.replace(toPath);\n    } else {\n      location.href = toPath;\n    }\n    if (inMiddleware) {\n      if (!nuxtApp.isHydrating) {\n        return false;\n      }\n      return new Promise(() => {\n      });\n    }\n    return Promise.resolve();\n  }\n  return options?.replace ? router.replace(to) : router.push(to);\n};\nexport const abortNavigation = (err) => {\n  if (import.meta.dev && !isProcessingMiddleware()) {\n    throw new Error(\"abortNavigation() is only usable inside a route middleware handler.\");\n  }\n  if (!err) {\n    return false;\n  }\n  err = createError(err);\n  if (err.fatal) {\n    useNuxtApp().runWithContext(() => showError(err));\n  }\n  throw err;\n};\nexport const setPageLayout = (layout) => {\n  const nuxtApp = useNuxtApp();\n  if (import.meta.server) {\n    if (import.meta.dev && getCurrentInstance() && nuxtApp.payload.state._layout !== layout) {\n      console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout on the server within a component as this will cause hydration errors.\");\n    }\n    nuxtApp.payload.state._layout = layout;\n  }\n  if (import.meta.dev && nuxtApp.isHydrating && nuxtApp.payload.serverRendered && nuxtApp.payload.state._layout !== layout) {\n    console.warn(\"[warn] [nuxt] `setPageLayout` should not be called to change the layout during hydration as this will cause hydration errors.\");\n  }\n  const inMiddleware = isProcessingMiddleware();\n  if (inMiddleware || import.meta.server || nuxtApp.isHydrating) {\n    const unsubscribe = useRouter().beforeResolve((to) => {\n      to.meta.layout = layout;\n      unsubscribe();\n    });\n  }\n  if (!inMiddleware) {\n    useRoute().meta.layout = layout;\n  }\n};\nexport function resolveRouteObject(to) {\n  return withQuery(to.path || \"\", to.query || {}) + (to.hash || \"\");\n}\nexport function encodeURL(location2, isExternalHost = false) {\n  const url = new URL(location2, \"http://localhost\");\n  if (!isExternalHost) {\n    return url.pathname + url.search + url.hash;\n  }\n  if (location2.startsWith(\"//\")) {\n    return url.toString().replace(url.protocol, \"\");\n  }\n  return url.toString();\n}\n","import { createError as createH3Error } from \"h3\";\nimport { toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { useRouter } from \"./router.js\";\nexport const NUXT_ERROR_SIGNATURE = \"__nuxt_error\";\nexport const useError = () => toRef(useNuxtApp().payload, \"error\");\nexport const showError = (error) => {\n  const nuxtError = createError(error);\n  try {\n    const nuxtApp = useNuxtApp();\n    const error2 = useError();\n    if (import.meta.client) {\n      nuxtApp.hooks.callHook(\"app:error\", nuxtError);\n    }\n    error2.value ||= nuxtError;\n  } catch {\n    throw nuxtError;\n  }\n  return nuxtError;\n};\nexport const clearError = async (options = {}) => {\n  const nuxtApp = useNuxtApp();\n  const error = useError();\n  nuxtApp.callHook(\"app:error:cleared\", options);\n  if (options.redirect) {\n    await useRouter().replace(options.redirect);\n  }\n  error.value = void 0;\n};\nexport const isNuxtError = (error) => !!error && typeof error === \"object\" && NUXT_ERROR_SIGNATURE in error;\nexport const createError = (error) => {\n  const nuxtError = createH3Error(error);\n  Object.defineProperty(nuxtError, NUXT_ERROR_SIGNATURE, {\n    value: true,\n    configurable: false,\n    writable: false\n  });\n  return nuxtError;\n};\n","import { createHead as createClientHead, renderDOMHead } from \"@unhead/vue/client\";\nimport { defineNuxtPlugin } from \"#app/nuxt\";\nimport unheadOptions from \"#build/unhead-options.mjs\";\nexport default defineNuxtPlugin({\n  name: \"nuxt:head\",\n  enforce: \"pre\",\n  setup(nuxtApp) {\n    const head = import.meta.server ? nuxtApp.ssrContext.head : createClientHead(unheadOptions);\n    nuxtApp.vueApp.use(head);\n    if (import.meta.client) {\n      let pauseDOMUpdates = true;\n      const syncHead = async () => {\n        pauseDOMUpdates = false;\n        await renderDOMHead(head);\n      };\n      head.hooks.hook(\"dom:beforeRender\", (context) => {\n        context.shouldRender = !pauseDOMUpdates;\n      });\n      nuxtApp.hooks.hook(\"page:start\", () => {\n        pauseDOMUpdates = true;\n      });\n      nuxtApp.hooks.hook(\"page:finish\", () => {\n        if (!nuxtApp.isHydrating) {\n          syncHead();\n        }\n      });\n      nuxtApp.hooks.hook(\"app:error\", syncHead);\n      nuxtApp.hooks.hook(\"app:suspense:resolve\", syncHead);\n    }\n  }\n});\n","import { KeepAlive, h } from \"vue\";\nconst ROUTE_KEY_PARENTHESES_RE = /(:\\w+)\\([^)]+\\)/g;\nconst ROUTE_KEY_SYMBOLS_RE = /(:\\w+)[?+*]/g;\nconst ROUTE_KEY_NORMAL_RE = /:\\w+/g;\nconst interpolatePath = (route, match) => {\n  return match.path.replace(ROUTE_KEY_PARENTHESES_RE, \"$1\").replace(ROUTE_KEY_SYMBOLS_RE, \"$1\").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || \"\");\n};\nexport const generateRouteKey = (routeProps, override) => {\n  const matchedRoute = routeProps.route.matched.find((m) => m.components?.default === routeProps.Component.type);\n  const source = override ?? matchedRoute?.meta.key ?? (matchedRoute && interpolatePath(routeProps.route, matchedRoute));\n  return typeof source === \"function\" ? source(routeProps.route) : source;\n};\nexport const wrapInKeepAlive = (props, children) => {\n  return { default: () => import.meta.client && props ? h(KeepAlive, props === true ? {} : props, children) : children };\n};\nexport function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n","\nif (import.meta.hot) {\n  import.meta.hot.accept((mod) => {\n    const router = import.meta.hot.data.router\n    const generateRoutes = import.meta.hot.data.generateRoutes\n    if (!router || !generateRoutes) {\n      import.meta.hot.invalidate('[nuxt] Cannot replace routes because there is no active router. Reloading.')\n      return\n    }\n    router.clearRoutes()\n    const routes = generateRoutes(mod.default || mod)\n    function addRoutes (routes) {\n      for (const route of routes) {\n        router.addRoute(route)\n      }\n      router.replace(router.currentRoute.value.fullPath)\n    }\n    if (routes && 'then' in routes) {\n      routes.then(addRoutes)\n    } else {\n      addRoutes(routes)\n    }\n  })\n}\n\nexport function handleHotUpdate(_router, _generateRoutes) {\n  if (import.meta.hot) {\n    import.meta.hot.data ||= {}\n    import.meta.hot.data.router = _router\n    import.meta.hot.data.generateRoutes = _generateRoutes\n  }\n}\nimport { default as indexiTCSRS60z196lKHr_cTIOfHCYrGiIQS96A6IJ_HlxJ0Meta } from \"/home/river/Projects/oc/nclinic.cz/app/pages/index.vue?macro=true\";\nexport default [\n  {\n    name: \"index\",\n    path: \"/\",\n    component: () => import(\"/home/river/Projects/oc/nclinic.cz/app/pages/index.vue\")\n  }\n]","import { Transition, createStaticVNode, h } from \"vue\";\nimport { isString, isPromise, isArray, isObject } from \"@vue/shared\";\nimport { START_LOCATION } from \"#build/pages\";\nexport const _wrapInTransition = (props, children) => {\n  return { default: () => import.meta.client && props ? h(Transition, props === true ? {} : props, children) : children.default?.() };\n};\nconst ROUTE_KEY_PARENTHESES_RE = /(:\\w+)\\([^)]+\\)/g;\nconst ROUTE_KEY_SYMBOLS_RE = /(:\\w+)[?+*]/g;\nconst ROUTE_KEY_NORMAL_RE = /:\\w+/g;\nfunction generateRouteKey(route) {\n  const source = route?.meta.key ?? route.path.replace(ROUTE_KEY_PARENTHESES_RE, \"$1\").replace(ROUTE_KEY_SYMBOLS_RE, \"$1\").replace(ROUTE_KEY_NORMAL_RE, (r) => route.params[r.slice(1)]?.toString() || \"\");\n  return typeof source === \"function\" ? source(route) : source;\n}\nexport function isChangingPage(to, from) {\n  if (to === from || from === START_LOCATION) {\n    return false;\n  }\n  if (generateRouteKey(to) !== generateRouteKey(from)) {\n    return true;\n  }\n  const areComponentsSame = to.matched.every(\n    (comp, index) => comp.components && comp.components.default === from.matched[index]?.components?.default\n  );\n  if (areComponentsSame) {\n    return false;\n  }\n  return true;\n}\nexport function createBuffer() {\n  let appendable = false;\n  const buffer = [];\n  return {\n    getBuffer() {\n      return buffer;\n    },\n    push(item) {\n      const isStringItem = isString(item);\n      if (appendable && isStringItem) {\n        buffer[buffer.length - 1] += item;\n      } else {\n        buffer.push(item);\n      }\n      appendable = isStringItem;\n      if (isPromise(item) || isArray(item) && item.hasAsync) {\n        buffer.hasAsync = true;\n      }\n    }\n  };\n}\nexport function vforToArray(source) {\n  if (isArray(source)) {\n    return source;\n  } else if (isString(source)) {\n    return source.split(\"\");\n  } else if (typeof source === \"number\") {\n    if (import.meta.dev && !Number.isInteger(source)) {\n      console.warn(`The v-for range expect an integer value but got ${source}.`);\n    }\n    const array = [];\n    for (let i = 0; i < source; i++) {\n      array[i] = i;\n    }\n    return array;\n  } else if (isObject(source)) {\n    if (source[Symbol.iterator]) {\n      return Array.from(\n        source,\n        (item) => item\n      );\n    } else {\n      const keys = Object.keys(source);\n      const array = new Array(keys.length);\n      for (let i = 0, l = keys.length; i < l; i++) {\n        const key = keys[i];\n        array[i] = source[key];\n      }\n      return array;\n    }\n  }\n  return [];\n}\nexport function getFragmentHTML(element, withoutSlots = false) {\n  if (element) {\n    if (element.nodeName === \"#comment\" && element.nodeValue === \"[\") {\n      return getFragmentChildren(element, [], withoutSlots);\n    }\n    if (withoutSlots) {\n      const clone = element.cloneNode(true);\n      clone.querySelectorAll(\"[data-island-slot]\").forEach((n) => {\n        n.innerHTML = \"\";\n      });\n      return [clone.outerHTML];\n    }\n    return [element.outerHTML];\n  }\n}\nfunction getFragmentChildren(element, blocks = [], withoutSlots = false) {\n  if (element && element.nodeName) {\n    if (isEndFragment(element)) {\n      return blocks;\n    } else if (!isStartFragment(element)) {\n      const clone = element.cloneNode(true);\n      if (withoutSlots) {\n        clone.querySelectorAll?.(\"[data-island-slot]\").forEach((n) => {\n          n.innerHTML = \"\";\n        });\n      }\n      blocks.push(clone.outerHTML);\n    }\n    getFragmentChildren(element.nextSibling, blocks, withoutSlots);\n  }\n  return blocks;\n}\nexport function elToStaticVNode(el, staticNodeFallback) {\n  const fragment = el ? getFragmentHTML(el) : staticNodeFallback ? [staticNodeFallback] : void 0;\n  if (fragment) {\n    return createStaticVNode(fragment.join(\"\"), fragment.length);\n  }\n  return h(\"div\");\n}\nexport function isStartFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"[\";\n}\nexport function isEndFragment(element) {\n  return element.nodeName === \"#comment\" && element.nodeValue === \"]\";\n}\n","import { START_LOCATION } from \"vue-router\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { isChangingPage } from \"#app/components/utils\";\nimport { useRouter } from \"#app/composables/router\";\nexport default {\n  scrollBehavior(to, from, savedPosition) {\n    const nuxtApp = useNuxtApp();\n    const hashScrollBehaviour = useRouter().options?.scrollBehaviorType ?? \"auto\";\n    if (to.path === from.path) {\n      if (from.hash && !to.hash) {\n        return { left: 0, top: 0 };\n      }\n      if (to.hash) {\n        return { el: to.hash, top: _getHashElementScrollMarginTop(to.hash), behavior: hashScrollBehaviour };\n      }\n      return false;\n    }\n    const routeAllowsScrollToTop = typeof to.meta.scrollToTop === \"function\" ? to.meta.scrollToTop(to, from) : to.meta.scrollToTop;\n    if (routeAllowsScrollToTop === false) {\n      return false;\n    }\n    const hookToWait = nuxtApp._runningTransition ? \"page:transition:finish\" : \"page:loading:end\";\n    return new Promise((resolve) => {\n      if (from === START_LOCATION) {\n        resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour));\n        return;\n      }\n      nuxtApp.hooks.hookOnce(hookToWait, () => {\n        requestAnimationFrame(() => resolve(_calculatePosition(to, from, savedPosition, hashScrollBehaviour)));\n      });\n    });\n  }\n};\nfunction _getHashElementScrollMarginTop(selector) {\n  try {\n    const elem = document.querySelector(selector);\n    if (elem) {\n      return (Number.parseFloat(getComputedStyle(elem).scrollMarginTop) || 0) + (Number.parseFloat(getComputedStyle(document.documentElement).scrollPaddingTop) || 0);\n    }\n  } catch {\n  }\n  return 0;\n}\nfunction _calculatePosition(to, from, savedPosition, defaultHashScrollBehaviour) {\n  if (savedPosition) {\n    return savedPosition;\n  }\n  const isPageNavigation = isChangingPage(to, from);\n  if (to.hash) {\n    return {\n      el: to.hash,\n      top: _getHashElementScrollMarginTop(to.hash),\n      behavior: isPageNavigation ? defaultHashScrollBehaviour : \"instant\"\n    };\n  }\n  return {\n    left: 0,\n    top: 0\n  };\n}\n","import routerOptions0 from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt/dist/pages/runtime/router.options.js\";\nconst configRouterOptions = {\n  hashMode: false,\n  scrollBehaviorType: \"auto\"\n}\nexport const hashMode = false\nexport default {\n...configRouterOptions,\n...routerOptions0,\n}","import validate from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt/dist/pages/runtime/validate.js\";\nimport manifest_45route_45rule from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt/dist/app/middleware/manifest-route-rule.js\";\nexport const globalMiddleware = [\n  validate,\n  manifest_45route_45rule\n]\nexport const namedMiddleware = {}","import { createError } from \"#app/composables/error\";\nimport { defineNuxtRouteMiddleware } from \"#app/composables/router\";\nexport default defineNuxtRouteMiddleware(async (to, from) => {\n  if (!to.meta?.validate) {\n    return;\n  }\n  const result = await Promise.resolve(to.meta.validate(to));\n  if (result === true) {\n    return;\n  }\n  const error = createError({\n    fatal: import.meta.client,\n    statusCode: result && result.statusCode || 404,\n    statusMessage: result && result.statusMessage || `Page Not Found: ${to.fullPath}`,\n    data: {\n      path: to.fullPath\n    }\n  });\n  if (typeof window !== \"undefined\") {\n    window.history.pushState({}, \"\", from.fullPath);\n  }\n  return error;\n});\n","import { hasProtocol } from \"ufo\";\nimport { defineNuxtRouteMiddleware } from \"../composables/router.js\";\nimport { getRouteRules } from \"../composables/manifest.js\";\nexport default defineNuxtRouteMiddleware(async (to) => {\n  if (import.meta.server || import.meta.test) {\n    return;\n  }\n  const rules = await getRouteRules({ path: to.path });\n  if (rules.redirect) {\n    if (hasProtocol(rules.redirect, { acceptRelative: true })) {\n      window.location.href = rules.redirect;\n      return false;\n    }\n    return rules.redirect;\n  }\n});\n","import { isReadonly, reactive, shallowReactive, shallowRef } from \"vue\";\nimport { START_LOCATION, createMemoryHistory, createRouter, createWebHashHistory, createWebHistory } from \"vue-router\";\nimport { isSamePath, withoutBase } from \"ufo\";\nimport { toArray } from \"../utils.js\";\nimport { getRouteRules } from \"#app/composables/manifest\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app/nuxt\";\nimport { clearError, createError, isNuxtError, showError, useError } from \"#app/composables/error\";\nimport { navigateTo } from \"#app/composables/router\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport _routes, { handleHotUpdate } from \"#build/routes\";\nimport routerOptions, { hashMode } from \"#build/router.options\";\nimport { globalMiddleware, namedMiddleware } from \"#build/middleware\";\nfunction createCurrentLocation(base, location, renderedPath) {\n  const { pathname, search, hash } = location;\n  const hashPos = base.indexOf(\"#\");\n  if (hashPos > -1) {\n    const slicePos = hash.includes(base.slice(hashPos)) ? base.slice(hashPos).length : 1;\n    let pathFromHash = hash.slice(slicePos);\n    if (pathFromHash[0] !== \"/\") {\n      pathFromHash = \"/\" + pathFromHash;\n    }\n    return withoutBase(pathFromHash, \"\");\n  }\n  const displayedPath = withoutBase(pathname, base);\n  const path = !renderedPath || isSamePath(displayedPath, renderedPath) ? displayedPath : renderedPath;\n  return path + (path.includes(\"?\") ? \"\" : search) + hash;\n}\nconst plugin = defineNuxtPlugin({\n  name: \"nuxt:router\",\n  enforce: \"pre\",\n  async setup(nuxtApp) {\n    let routerBase = useRuntimeConfig().app.baseURL;\n    if (hashMode && !routerBase.includes(\"#\")) {\n      routerBase += \"#\";\n    }\n    const history = routerOptions.history?.(routerBase) ?? (import.meta.client ? hashMode ? createWebHashHistory(routerBase) : createWebHistory(routerBase) : createMemoryHistory(routerBase));\n    const routes = routerOptions.routes ? await routerOptions.routes(_routes) ?? _routes : _routes;\n    let startPosition;\n    const router = createRouter({\n      ...routerOptions,\n      scrollBehavior: (to, from, savedPosition) => {\n        if (from === START_LOCATION) {\n          startPosition = savedPosition;\n          return;\n        }\n        if (routerOptions.scrollBehavior) {\n          router.options.scrollBehavior = routerOptions.scrollBehavior;\n          if (\"scrollRestoration\" in window.history) {\n            const unsub = router.beforeEach(() => {\n              unsub();\n              window.history.scrollRestoration = \"manual\";\n            });\n          }\n          return routerOptions.scrollBehavior(to, START_LOCATION, startPosition || savedPosition);\n        }\n      },\n      history,\n      routes\n    });\n    if (import.meta.hot) {\n      handleHotUpdate(router, routerOptions.routes ? routerOptions.routes : (routes2) => routes2);\n    }\n    if (import.meta.client && \"scrollRestoration\" in window.history) {\n      window.history.scrollRestoration = \"auto\";\n    }\n    nuxtApp.vueApp.use(router);\n    const previousRoute = shallowRef(router.currentRoute.value);\n    router.afterEach((_to, from) => {\n      previousRoute.value = from;\n    });\n    Object.defineProperty(nuxtApp.vueApp.config.globalProperties, \"previousRoute\", {\n      get: () => previousRoute.value\n    });\n    const initialURL = import.meta.server ? nuxtApp.ssrContext.url : createCurrentLocation(routerBase, window.location, nuxtApp.payload.path);\n    const _route = shallowRef(router.currentRoute.value);\n    const syncCurrentRoute = () => {\n      _route.value = router.currentRoute.value;\n    };\n    nuxtApp.hook(\"page:finish\", syncCurrentRoute);\n    router.afterEach((to, from) => {\n      if (to.matched[0]?.components?.default === from.matched[0]?.components?.default) {\n        syncCurrentRoute();\n      }\n    });\n    const route = {};\n    for (const key in _route.value) {\n      Object.defineProperty(route, key, {\n        get: () => _route.value[key],\n        enumerable: true\n      });\n    }\n    nuxtApp._route = shallowReactive(route);\n    nuxtApp._middleware ||= {\n      global: [],\n      named: {}\n    };\n    const error = useError();\n    if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n      router.afterEach(async (to, _from, failure) => {\n        delete nuxtApp._processingMiddleware;\n        if (import.meta.client && !nuxtApp.isHydrating && error.value) {\n          await nuxtApp.runWithContext(clearError);\n        }\n        if (failure) {\n          await nuxtApp.callHook(\"page:loading:end\");\n        }\n        if (import.meta.server && failure?.type === 4) {\n          return;\n        }\n        if (import.meta.server && to.redirectedFrom && to.fullPath !== initialURL) {\n          await nuxtApp.runWithContext(() => navigateTo(to.fullPath || \"/\"));\n        }\n      });\n    }\n    try {\n      if (import.meta.server) {\n        await router.push(initialURL);\n      }\n      await router.isReady();\n    } catch (error2) {\n      await nuxtApp.runWithContext(() => showError(error2));\n    }\n    const resolvedInitialRoute = import.meta.client && initialURL !== router.currentRoute.value.fullPath ? router.resolve(initialURL) : router.currentRoute.value;\n    syncCurrentRoute();\n    if (import.meta.server && nuxtApp.ssrContext?.islandContext) {\n      return { provide: { router } };\n    }\n    const initialLayout = nuxtApp.payload.state._layout;\n    router.beforeEach(async (to, from) => {\n      await nuxtApp.callHook(\"page:loading:start\");\n      to.meta = reactive(to.meta);\n      if (nuxtApp.isHydrating && initialLayout && !isReadonly(to.meta.layout)) {\n        to.meta.layout = initialLayout;\n      }\n      nuxtApp._processingMiddleware = true;\n      if (import.meta.client || !nuxtApp.ssrContext?.islandContext) {\n        const middlewareEntries = /* @__PURE__ */ new Set([...globalMiddleware, ...nuxtApp._middleware.global]);\n        for (const component of to.matched) {\n          const componentMiddleware = component.meta.middleware;\n          if (!componentMiddleware) {\n            continue;\n          }\n          for (const entry of toArray(componentMiddleware)) {\n            middlewareEntries.add(entry);\n          }\n        }\n        if (isAppManifestEnabled) {\n          const routeRules = await nuxtApp.runWithContext(() => getRouteRules({ path: to.path }));\n          if (routeRules.appMiddleware) {\n            for (const key in routeRules.appMiddleware) {\n              if (routeRules.appMiddleware[key]) {\n                middlewareEntries.add(key);\n              } else {\n                middlewareEntries.delete(key);\n              }\n            }\n          }\n        }\n        for (const entry of middlewareEntries) {\n          const middleware = typeof entry === \"string\" ? nuxtApp._middleware.named[entry] || await namedMiddleware[entry]?.().then((r) => r.default || r) : entry;\n          if (!middleware) {\n            if (import.meta.dev) {\n              throw new Error(`Unknown route middleware: '${entry}'. Valid middleware: ${Object.keys(namedMiddleware).map((mw) => `'${mw}'`).join(\", \")}.`);\n            }\n            throw new Error(`Unknown route middleware: '${entry}'.`);\n          }\n          try {\n            const result = await nuxtApp.runWithContext(() => middleware(to, from));\n            if (import.meta.server || !nuxtApp.payload.serverRendered && nuxtApp.isHydrating) {\n              if (result === false || result instanceof Error) {\n                const error2 = result || createError({\n                  statusCode: 404,\n                  statusMessage: `Page Not Found: ${initialURL}`\n                });\n                await nuxtApp.runWithContext(() => showError(error2));\n                return false;\n              }\n            }\n            if (result === true) {\n              continue;\n            }\n            if (result === false) {\n              return result;\n            }\n            if (result) {\n              if (isNuxtError(result) && result.fatal) {\n                await nuxtApp.runWithContext(() => showError(result));\n              }\n              return result;\n            }\n          } catch (err) {\n            const error2 = createError(err);\n            if (error2.fatal) {\n              await nuxtApp.runWithContext(() => showError(error2));\n            }\n            return error2;\n          }\n        }\n      }\n    });\n    router.onError(async () => {\n      delete nuxtApp._processingMiddleware;\n      await nuxtApp.callHook(\"page:loading:end\");\n    });\n    router.afterEach(async (to, _from) => {\n      if (to.matched.length === 0) {\n        await nuxtApp.runWithContext(() => showError(createError({\n          statusCode: 404,\n          fatal: false,\n          statusMessage: `Page not found: ${to.fullPath}`,\n          data: {\n            path: to.fullPath\n          }\n        })));\n      }\n    });\n    nuxtApp.hooks.hookOnce(\"app:created\", async () => {\n      try {\n        if (\"name\" in resolvedInitialRoute) {\n          resolvedInitialRoute.name = void 0;\n        }\n        await router.replace({\n          ...resolvedInitialRoute,\n          force: true\n        });\n        router.options.scrollBehavior = routerOptions.scrollBehavior;\n      } catch (error2) {\n        await nuxtApp.runWithContext(() => showError(error2));\n      }\n    });\n    return { provide: { router } };\n  }\n});\nexport default plugin;\n","import { createMatcherFromExport, createRouter as createRadixRouter, toRouteMatcher } from \"radix3\";\nimport { defu } from \"defu\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { appManifest as isAppManifestEnabled } from \"#build/nuxt.config.mjs\";\nimport { buildAssetsURL } from \"#internal/nuxt/paths\";\nlet manifest;\nlet matcher;\nfunction fetchManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  if (import.meta.server) {\n    manifest = import(\n      /* webpackIgnore: true */\n      /* @vite-ignore */\n      \"#app-manifest\"\n    );\n  } else {\n    manifest = $fetch(buildAssetsURL(`builds/meta/${useRuntimeConfig().app.buildId}.json`), {\n      responseType: \"json\"\n    });\n  }\n  manifest.then((m) => {\n    matcher = createMatcherFromExport(m.matcher);\n  }).catch((e) => {\n    console.error(\"[nuxt] Error fetching app manifest.\", e);\n  });\n  return manifest;\n}\nexport function getAppManifest() {\n  if (!isAppManifestEnabled) {\n    throw new Error(\"[nuxt] app manifest should be enabled with `experimental.appManifest`\");\n  }\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._preloadManifest = true;\n  }\n  return manifest || fetchManifest();\n}\nexport async function getRouteRules(arg) {\n  const path = typeof arg === \"string\" ? arg : arg.path;\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._preloadManifest = true;\n    const _routeRulesMatcher = toRouteMatcher(\n      createRadixRouter({ routes: useRuntimeConfig().nitro.routeRules })\n    );\n    return defu({}, ..._routeRulesMatcher.matchAll(path).reverse());\n  }\n  await getAppManifest();\n  if (!matcher) {\n    console.error(\"[nuxt] Error creating app manifest matcher.\", matcher);\n    return {};\n  }\n  try {\n    return defu({}, ...matcher.matchAll(path).reverse());\n  } catch (e) {\n    console.error(\"[nuxt] Error matching route rules.\", e);\n    return {};\n  }\n}\n","import { hasInjectionContext, inject } from \"vue\";\nimport {\n  useHead as headCore,\n  useHeadSafe as headSafe,\n  headSymbol,\n  useSeoMeta as seoMeta,\n  useServerHead as serverHead,\n  useServerHeadSafe as serverHeadSafe,\n  useServerSeoMeta as serverSeoMeta\n} from \"@unhead/vue\";\nimport { useNuxtApp } from \"#app/nuxt\";\nexport function injectHead(nuxtApp) {\n  const nuxt = nuxtApp || useNuxtApp();\n  return nuxt.ssrContext?.head || nuxt.runWithContext(() => {\n    if (hasInjectionContext()) {\n      const head = inject(headSymbol);\n      if (!head) {\n        throw new Error(\"[nuxt] [unhead] Missing Unhead instance.\");\n      }\n      return head;\n    }\n  });\n}\nexport function useHead(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return headCore(input, { head, ...options });\n}\nexport function useHeadSafe(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return headSafe(input, { head, ...options });\n}\nexport function useSeoMeta(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return seoMeta(input, { head, ...options });\n}\nexport function useServerHead(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return serverHead(input, { head, ...options });\n}\nexport function useServerHeadSafe(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return serverHeadSafe(input, { head, ...options });\n}\nexport function useServerSeoMeta(input, options = {}) {\n  const head = injectHead(options.nuxt);\n  return serverSeoMeta(input, { head, ...options });\n}\n","import { createElementBlock, defineComponent } from \"vue\";\nexport default defineComponent({\n  name: \"ServerPlaceholder\",\n  render() {\n    return createElementBlock(\"div\");\n  }\n});\n","import { cloneVNode, createElementBlock, defineComponent, getCurrentInstance, h, onMounted, provide, shallowRef } from \"vue\";\nimport { isPromise } from \"@vue/shared\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport ServerPlaceholder from \"./server-placeholder.js\";\nimport { elToStaticVNode } from \"./utils.js\";\nexport const clientOnlySymbol = Symbol.for(\"nuxt:client-only\");\nconst STATIC_DIV = \"<div></div>\";\nexport default defineComponent({\n  name: \"ClientOnly\",\n  inheritAttrs: false,\n  props: [\"fallback\", \"placeholder\", \"placeholderTag\", \"fallbackTag\"],\n  ...import.meta.dev && {\n    slots: Object\n  },\n  setup(props, { slots, attrs }) {\n    const mounted = shallowRef(false);\n    onMounted(() => {\n      mounted.value = true;\n    });\n    if (import.meta.dev) {\n      const nuxtApp = useNuxtApp();\n      nuxtApp._isNuxtPageUsed = true;\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    const vm = getCurrentInstance();\n    if (vm) {\n      vm._nuxtClientOnly = true;\n    }\n    provide(clientOnlySymbol, true);\n    return () => {\n      if (mounted.value) {\n        const vnodes = slots.default?.();\n        if (vnodes && vnodes.length === 1) {\n          return [cloneVNode(vnodes[0], attrs)];\n        }\n        return vnodes;\n      }\n      const slot = slots.fallback || slots.placeholder;\n      if (slot) {\n        return h(slot);\n      }\n      const fallbackStr = props.fallback || props.placeholder || \"\";\n      const fallbackTag = props.fallbackTag || props.placeholderTag || \"span\";\n      return createElementBlock(fallbackTag, attrs, fallbackStr);\n    };\n  }\n});\nconst cache = /* @__PURE__ */ new WeakMap();\n// @__NO_SIDE_EFFECTS__\nexport function createClientOnly(component) {\n  if (import.meta.server) {\n    return ServerPlaceholder;\n  }\n  if (cache.has(component)) {\n    return cache.get(component);\n  }\n  const clone = { ...component };\n  if (clone.render) {\n    clone.render = (ctx, cache2, $props, $setup, $data, $options) => {\n      if ($setup.mounted$ ?? ctx.mounted$) {\n        const res = component.render?.bind(ctx)(ctx, cache2, $props, $setup, $data, $options);\n        return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n      }\n      return elToStaticVNode(ctx._.vnode.el, STATIC_DIV);\n    };\n  } else {\n    clone.template &&= `\n      <template v-if=\"mounted$\">${component.template}</template>\n      <template v-else>${STATIC_DIV}</template>\n    `;\n  }\n  clone.setup = (props, ctx) => {\n    const nuxtApp = useNuxtApp();\n    const mounted$ = shallowRef(nuxtApp.isHydrating === false);\n    const instance = getCurrentInstance();\n    if (nuxtApp.isHydrating) {\n      const attrs = { ...instance.attrs };\n      const directives = extractDirectives(instance);\n      for (const key in attrs) {\n        delete instance.attrs[key];\n      }\n      onMounted(() => {\n        Object.assign(instance.attrs, attrs);\n        instance.vnode.dirs = directives;\n      });\n    }\n    onMounted(() => {\n      mounted$.value = true;\n    });\n    const setupState = component.setup?.(props, ctx) || {};\n    if (isPromise(setupState)) {\n      return Promise.resolve(setupState).then((setupState2) => {\n        if (typeof setupState2 !== \"function\") {\n          setupState2 ||= {};\n          setupState2.mounted$ = mounted$;\n          return setupState2;\n        }\n        return (...args) => {\n          if (mounted$.value || !nuxtApp.isHydrating) {\n            const res = setupState2(...args);\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res) : h(res);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      });\n    } else {\n      if (typeof setupState === \"function\") {\n        return (...args) => {\n          if (mounted$.value) {\n            const res = setupState(...args);\n            const attrs = clone.inheritAttrs !== false ? ctx.attrs : void 0;\n            return res.children === null || typeof res.children === \"string\" ? cloneVNode(res, attrs) : h(res, attrs);\n          }\n          return elToStaticVNode(instance?.vnode.el, STATIC_DIV);\n        };\n      }\n      return Object.assign(setupState, { mounted$ });\n    }\n  };\n  cache.set(component, clone);\n  return clone;\n}\nfunction extractDirectives(instance) {\n  if (!instance || !instance.vnode.dirs) {\n    return null;\n  }\n  const directives = instance.vnode.dirs;\n  instance.vnode.dirs = null;\n  return directives;\n}\n","import { setResponseStatus as _setResponseStatus, appendHeader, getRequestHeader, getRequestHeaders, getResponseHeader, removeResponseHeader, setResponseHeader } from \"h3\";\nimport { computed, getCurrentInstance, ref } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nimport { useHead } from \"./head.js\";\nexport function useRequestEvent(nuxtApp) {\n  if (import.meta.client) {\n    return;\n  }\n  nuxtApp ||= useNuxtApp();\n  return nuxtApp.ssrContext?.event;\n}\nexport function useRequestHeaders(include) {\n  if (import.meta.client) {\n    return {};\n  }\n  const event = useRequestEvent();\n  const _headers = event ? getRequestHeaders(event) : {};\n  if (!include || !event) {\n    return _headers;\n  }\n  const headers = /* @__PURE__ */ Object.create(null);\n  for (const _key of include) {\n    const key = _key.toLowerCase();\n    const header = _headers[key];\n    if (header) {\n      headers[key] = header;\n    }\n  }\n  return headers;\n}\nexport function useRequestHeader(header) {\n  if (import.meta.client) {\n    return void 0;\n  }\n  const event = useRequestEvent();\n  return event ? getRequestHeader(event, header) : void 0;\n}\nexport function useRequestFetch() {\n  if (import.meta.client) {\n    return globalThis.$fetch;\n  }\n  return useRequestEvent()?.$fetch || globalThis.$fetch;\n}\nexport function setResponseStatus(arg1, arg2, arg3) {\n  if (import.meta.client) {\n    return;\n  }\n  if (arg1 && typeof arg1 !== \"number\") {\n    return _setResponseStatus(arg1, arg2, arg3);\n  }\n  const event = useRequestEvent();\n  if (event) {\n    return _setResponseStatus(event, arg1, arg2);\n  }\n}\nexport function useResponseHeader(header) {\n  if (import.meta.client) {\n    if (import.meta.dev) {\n      return computed({\n        get: () => void 0,\n        set: () => console.warn(\"[nuxt] Setting response headers is not supported in the browser.\")\n      });\n    }\n    return ref();\n  }\n  const event = useRequestEvent();\n  return computed({\n    get() {\n      return getResponseHeader(event, header);\n    },\n    set(newValue) {\n      if (!newValue) {\n        return removeResponseHeader(event, header);\n      }\n      return setResponseHeader(event, header, newValue);\n    }\n  });\n}\nexport function prerenderRoutes(path) {\n  if (!import.meta.server || !import.meta.prerender) {\n    return;\n  }\n  const paths = toArray(path);\n  appendHeader(useRequestEvent(), \"x-nitro-prerender\", paths.map((p) => encodeURIComponent(p)).join(\", \"));\n}\nconst PREHYDRATE_ATTR_KEY = \"data-prehydrate-id\";\nexport function onPrehydrate(callback, key) {\n  if (import.meta.client) {\n    return;\n  }\n  if (typeof callback !== \"string\") {\n    throw new TypeError(\"[nuxt] To transform a callback into a string, `onPrehydrate` must be processed by the Nuxt build pipeline. If it is called in a third-party library, make sure to add the library to `build.transpile`.\");\n  }\n  const vm = getCurrentInstance();\n  if (vm && key) {\n    vm.attrs[PREHYDRATE_ATTR_KEY] ||= \"\";\n    key = \":\" + key + \":\";\n    if (!vm.attrs[PREHYDRATE_ATTR_KEY].includes(key)) {\n      vm.attrs[PREHYDRATE_ATTR_KEY] += key;\n    }\n  }\n  const code = vm && key ? `document.querySelectorAll('[${PREHYDRATE_ATTR_KEY}*=${JSON.stringify(key)}]').forEach` + callback : callback + \"()\";\n  useHead({\n    script: [{\n      key: vm && key ? key : void 0,\n      tagPosition: \"bodyClose\",\n      tagPriority: \"critical\",\n      innerHTML: code\n    }]\n  });\n  return vm && key ? vm.attrs[PREHYDRATE_ATTR_KEY] : void 0;\n}\n","export function toArray(value) {\n  return Array.isArray(value) ? value : [value];\n}\n","import { hasProtocol, joinURL, withoutTrailingSlash } from \"ufo\";\nimport { parse } from \"devalue\";\nimport { getCurrentInstance, onServerPrefetch, reactive } from \"vue\";\nimport { useNuxtApp, useRuntimeConfig } from \"../nuxt.js\";\nimport { useHead } from \"./head.js\";\nimport { useRoute } from \"./router.js\";\nimport { getAppManifest, getRouteRules } from \"./manifest.js\";\nimport { appId, appManifest, multiApp, payloadExtraction, renderJsonPayloads } from \"#build/nuxt.config.mjs\";\nexport async function loadPayload(url, opts = {}) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const shouldLoadPayload = await isPrerendered(url);\n  if (!shouldLoadPayload) {\n    return null;\n  }\n  const payloadURL = await _getPayloadURL(url, opts);\n  return await _importPayload(payloadURL) || null;\n}\nlet linkRelType;\nfunction detectLinkRelType() {\n  if (import.meta.server) {\n    return \"preload\";\n  }\n  if (linkRelType) {\n    return linkRelType;\n  }\n  const relList = document.createElement(\"link\").relList;\n  linkRelType = relList && relList.supports && relList.supports(\"prefetch\") ? \"prefetch\" : \"preload\";\n  return linkRelType;\n}\nexport function preloadPayload(url, opts = {}) {\n  const nuxtApp = useNuxtApp();\n  const promise = _getPayloadURL(url, opts).then((payloadURL) => {\n    const link = renderJsonPayloads ? { rel: detectLinkRelType(), as: \"fetch\", crossorigin: \"anonymous\", href: payloadURL } : { rel: \"modulepreload\", crossorigin: \"\", href: payloadURL };\n    if (import.meta.server) {\n      nuxtApp.runWithContext(() => useHead({ link: [link] }));\n    } else {\n      const linkEl = document.createElement(\"link\");\n      for (const key of Object.keys(link)) {\n        linkEl[key === \"crossorigin\" ? \"crossOrigin\" : key] = link[key];\n      }\n      document.head.appendChild(linkEl);\n      return new Promise((resolve, reject) => {\n        linkEl.addEventListener(\"load\", () => resolve());\n        linkEl.addEventListener(\"error\", () => reject());\n      });\n    }\n  });\n  if (import.meta.server) {\n    onServerPrefetch(() => promise);\n  }\n  return promise;\n}\nconst filename = renderJsonPayloads ? \"_payload.json\" : \"_payload.js\";\nasync function _getPayloadURL(url, opts = {}) {\n  const u = new URL(url, \"http://localhost\");\n  if (u.host !== \"localhost\" || hasProtocol(u.pathname, { acceptRelative: true })) {\n    throw new Error(\"Payload URL must not include hostname: \" + url);\n  }\n  const config = useRuntimeConfig();\n  const hash = opts.hash || (opts.fresh ? Date.now() : config.app.buildId);\n  const cdnURL = config.app.cdnURL;\n  const baseOrCdnURL = cdnURL && await isPrerendered(url) ? cdnURL : config.app.baseURL;\n  return joinURL(baseOrCdnURL, u.pathname, filename + (hash ? `?${hash}` : \"\"));\n}\nasync function _importPayload(payloadURL) {\n  if (import.meta.server || !payloadExtraction) {\n    return null;\n  }\n  const payloadPromise = renderJsonPayloads ? fetch(payloadURL, { cache: \"force-cache\" }).then((res) => res.text().then(parsePayload)) : import(\n    /* webpackIgnore: true */\n    /* @vite-ignore */\n    payloadURL\n  ).then((r) => r.default || r);\n  try {\n    return await payloadPromise;\n  } catch (err) {\n    console.warn(\"[nuxt] Cannot load payload \", payloadURL, err);\n  }\n  return null;\n}\nexport async function isPrerendered(url = useRoute().path) {\n  const nuxtApp = useNuxtApp();\n  if (!appManifest) {\n    return !!nuxtApp.payload.prerenderedAt;\n  }\n  url = withoutTrailingSlash(url);\n  const manifest = await getAppManifest();\n  if (manifest.prerendered.includes(url)) {\n    return true;\n  }\n  return nuxtApp.runWithContext(async () => {\n    const rules = await getRouteRules({ path: url });\n    return !!rules.prerender && !rules.redirect;\n  });\n}\nlet payloadCache = null;\nexport async function getNuxtClientPayload() {\n  if (import.meta.server) {\n    return null;\n  }\n  if (payloadCache) {\n    return payloadCache;\n  }\n  const el = multiApp ? document.querySelector(`[data-nuxt-data=\"${appId}\"]`) : document.getElementById(\"__NUXT_DATA__\");\n  if (!el) {\n    return {};\n  }\n  const inlineData = await parsePayload(el.textContent || \"\");\n  const externalData = el.dataset.src ? await _importPayload(el.dataset.src) : void 0;\n  payloadCache = {\n    ...inlineData,\n    ...externalData,\n    ...multiApp ? window.__NUXT__?.[appId] : window.__NUXT__\n  };\n  if (payloadCache.config?.public) {\n    payloadCache.config.public = reactive(payloadCache.config.public);\n  }\n  return payloadCache;\n}\nexport async function parsePayload(payload) {\n  return await parse(payload, useNuxtApp()._payloadRevivers);\n}\nexport function definePayloadReducer(name, reduce) {\n  if (import.meta.server) {\n    useNuxtApp().ssrContext._payloadReducers[name] = reduce;\n  }\n}\nexport function definePayloadReviver(name, revive) {\n  if (import.meta.dev && getCurrentInstance()) {\n    console.warn(\"[nuxt] [definePayloadReviver] This function must be called in a Nuxt plugin that is `unshift`ed to the beginning of the Nuxt plugins array.\");\n  }\n  if (import.meta.client) {\n    useNuxtApp()._payloadRevivers[name] = revive;\n  }\n}\n","import { defineNuxtPlugin, useRequestEvent, useRuntimeConfig, useState } from \"#app\";\nimport { createSiteConfigStack } from \"site-config-stack\";\nexport default defineNuxtPlugin({\n  name: \"nuxt-site-config:init\",\n  enforce: \"pre\",\n  async setup(nuxtApp) {\n    const stack = import.meta.server ? useRequestEvent()?.context?.siteConfig : createSiteConfigStack();\n    const state = useState(\"site-config\");\n    if (import.meta.server) {\n      nuxtApp.hooks.hook(\"app:rendered\", () => {\n        state.value = stack?.get({\n          debug: useRuntimeConfig()[\"nuxt-site-config\"].debug,\n          resolveRefs: true\n        });\n      });\n    }\n    if (import.meta.client) {\n      const store = state.value || window.__NUXT_SITE_CONFIG__ || {};\n      for (const k in store) {\n        if (k[0] !== \"_\") {\n          stack.push({ [k]: store[k], _priority: store._priority?.[k] || -1 });\n        }\n      }\n    }\n    return {\n      provide: {\n        nuxtSiteConfig: stack\n      }\n    };\n  }\n});\n","import { isRef, toRef } from \"vue\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { toArray } from \"../utils.js\";\nconst useStateKeyPrefix = \"$s\";\nexport function useState(...args) {\n  const autoKey = typeof args[args.length - 1] === \"string\" ? args.pop() : void 0;\n  if (typeof args[0] !== \"string\") {\n    args.unshift(autoKey);\n  }\n  const [_key, init] = args;\n  if (!_key || typeof _key !== \"string\") {\n    throw new TypeError(\"[nuxt] [useState] key must be a string: \" + _key);\n  }\n  if (init !== void 0 && typeof init !== \"function\") {\n    throw new Error(\"[nuxt] [useState] init must be a function: \" + init);\n  }\n  const key = useStateKeyPrefix + _key;\n  const nuxtApp = useNuxtApp();\n  const state = toRef(nuxtApp.payload.state, key);\n  if (state.value === void 0 && init) {\n    const initialValue = init();\n    if (isRef(initialValue)) {\n      nuxtApp.payload.state[key] = initialValue;\n      return initialValue;\n    }\n    state.value = initialValue;\n  }\n  return state;\n}\nexport function clearNuxtState(keys) {\n  const nuxtApp = useNuxtApp();\n  const _allKeys = Object.keys(nuxtApp.payload.state).map((key) => key.substring(useStateKeyPrefix.length));\n  const _keys = !keys ? _allKeys : typeof keys === \"function\" ? _allKeys.filter(keys) : toArray(keys);\n  for (const _key of _keys) {\n    const key = useStateKeyPrefix + _key;\n    if (key in nuxtApp.payload.state) {\n      nuxtApp.payload.state[key] = void 0;\n    }\n  }\n}\n","import { isReactive, isRef, isShallow, toRaw } from \"vue\";\nimport { definePayloadReducer } from \"../composables/payload.js\";\nimport { isNuxtError } from \"../composables/error.js\";\nimport { defineNuxtPlugin } from \"../nuxt.js\";\nimport { componentIslands } from \"#build/nuxt.config.mjs\";\nconst reducers = [\n  [\"NuxtError\", (data) => isNuxtError(data) && data.toJSON()],\n  [\"EmptyShallowRef\", (data) => isRef(data) && isShallow(data) && !data.value && (typeof data.value === \"bigint\" ? \"0n\" : JSON.stringify(data.value) || \"_\")],\n  [\"EmptyRef\", (data) => isRef(data) && !data.value && (typeof data.value === \"bigint\" ? \"0n\" : JSON.stringify(data.value) || \"_\")],\n  [\"ShallowRef\", (data) => isRef(data) && isShallow(data) && data.value],\n  [\"ShallowReactive\", (data) => isReactive(data) && isShallow(data) && toRaw(data)],\n  [\"Ref\", (data) => isRef(data) && data.value],\n  [\"Reactive\", (data) => isReactive(data) && toRaw(data)]\n];\nif (componentIslands) {\n  reducers.push([\"Island\", (data) => data && data?.__nuxt_island]);\n}\nexport default defineNuxtPlugin({\n  name: \"nuxt:revive-payload:server\",\n  setup() {\n    for (const [reducer, fn] of reducers) {\n      definePayloadReducer(reducer, fn);\n    }\n  }\n});\n","import {\n  useNuxtApp,\n  useRequestEvent\n} from \"#app\";\nimport { defu } from \"defu\";\nimport { reactive, watchEffect } from \"vue\";\nexport function useSiteConfig(options) {\n  const stack = import.meta.server ? useRequestEvent()?.context.siteConfig.get(defu({ resolveRefs: true }, options)) : reactive({});\n  if (import.meta.client) {\n    watchEffect(() => {\n      const data = useNuxtApp().$nuxtSiteConfig.get(defu({ resolveRefs: true }, options));\n      if (stack && data) {\n        Object.assign(stack, data);\n      }\n    });\n  }\n  delete stack._priority;\n  return stack;\n}\n","import { defu } from \"defu\";\nimport { useRuntimeConfig } from \"nuxt/app\";\nexport function useSchemaOrgConfig() {\n  const runtimeConfig = useRuntimeConfig();\n  return defu(import.meta.client ? runtimeConfig.public[\"nuxt-schema-org\"] : runtimeConfig[\"nuxt-schema-org\"], {\n    scriptAttributes: {}\n  });\n}\n","import { useHead, useServerHead } from \"@unhead/vue\";\nimport { useSchemaOrgConfig } from \"../utils/config.js\";\nexport function useSchemaOrg(input) {\n  const config = useSchemaOrgConfig();\n  const script = {\n    type: \"application/ld+json\",\n    key: \"schema-org-graph\",\n    nodes: input,\n    tagPriority: \"high\",\n    ...config.scriptAttributes\n  };\n  if (import.meta.dev) {\n    return useHead({\n      script: [script]\n    });\n  }\n  if (import.meta.server) {\n    return useServerHead({\n      script: [script]\n    });\n  } else if (config?.reactive) {\n    return useHead({\n      script: [script]\n    });\n  }\n}\n","import { hasProtocol, parseURL, withLeadingSlash, withoutTrailingSlash, withBase, withTrailingSlash } from 'ufo';\n\nfunction resolveSitePath(pathOrUrl, options) {\n  let path = pathOrUrl;\n  if (hasProtocol(pathOrUrl, { strict: false, acceptRelative: true })) {\n    const parsed = parseURL(pathOrUrl);\n    path = parsed.pathname;\n  }\n  const base = withLeadingSlash(options.base || \"/\");\n  if (base !== \"/\" && path.startsWith(base)) {\n    path = path.slice(base.length);\n  }\n  let origin = withoutTrailingSlash(options.absolute ? options.siteUrl : \"\");\n  if (base !== \"/\" && origin.endsWith(base)) {\n    origin = origin.slice(0, origin.indexOf(base));\n  }\n  const baseWithOrigin = options.withBase ? withBase(base, origin || \"/\") : origin;\n  const resolvedUrl = withBase(path, baseWithOrigin);\n  return path === \"/\" && !options.withBase ? withTrailingSlash(resolvedUrl) : fixSlashes(options.trailingSlash, resolvedUrl);\n}\nconst fileExtensions = [\n  // Images\n  \"jpg\",\n  \"jpeg\",\n  \"png\",\n  \"gif\",\n  \"bmp\",\n  \"webp\",\n  \"svg\",\n  \"ico\",\n  // Documents\n  \"pdf\",\n  \"doc\",\n  \"docx\",\n  \"xls\",\n  \"xlsx\",\n  \"ppt\",\n  \"pptx\",\n  \"txt\",\n  \"md\",\n  \"markdown\",\n  // Archives\n  \"zip\",\n  \"rar\",\n  \"7z\",\n  \"tar\",\n  \"gz\",\n  // Audio\n  \"mp3\",\n  \"wav\",\n  \"flac\",\n  \"ogg\",\n  \"opus\",\n  \"m4a\",\n  \"aac\",\n  \"midi\",\n  \"mid\",\n  // Video\n  \"mp4\",\n  \"avi\",\n  \"mkv\",\n  \"mov\",\n  \"wmv\",\n  \"flv\",\n  \"webm\",\n  // Web\n  \"html\",\n  \"css\",\n  \"js\",\n  \"json\",\n  \"xml\",\n  \"tsx\",\n  \"jsx\",\n  \"ts\",\n  \"vue\",\n  \"svelte\",\n  \"xsl\",\n  \"rss\",\n  \"atom\",\n  // Programming\n  \"php\",\n  \"py\",\n  \"rb\",\n  \"java\",\n  \"c\",\n  \"cpp\",\n  \"h\",\n  \"go\",\n  // Data formats\n  \"csv\",\n  \"tsv\",\n  \"sql\",\n  \"yaml\",\n  \"yml\",\n  // Fonts\n  \"woff\",\n  \"woff2\",\n  \"ttf\",\n  \"otf\",\n  \"eot\",\n  // Executables/Binaries\n  \"exe\",\n  \"msi\",\n  \"apk\",\n  \"ipa\",\n  \"dmg\",\n  \"iso\",\n  \"bin\",\n  // Scripts/Config\n  \"bat\",\n  \"cmd\",\n  \"sh\",\n  \"env\",\n  \"htaccess\",\n  \"conf\",\n  \"toml\",\n  \"ini\",\n  // Package formats\n  \"deb\",\n  \"rpm\",\n  \"jar\",\n  \"war\",\n  // E-books\n  \"epub\",\n  \"mobi\",\n  // Common temporary/backup files\n  \"log\",\n  \"tmp\",\n  \"bak\",\n  \"old\",\n  \"sav\"\n];\nfunction isPathFile(path) {\n  const lastSegment = path.split(\"/\").pop();\n  const ext = (lastSegment || path).match(/\\.[0-9a-z]+$/i)?.[0];\n  return ext && fileExtensions.includes(ext.replace(\".\", \"\"));\n}\nfunction fixSlashes(trailingSlash, pathOrUrl) {\n  const $url = parseURL(pathOrUrl);\n  if (isPathFile($url.pathname))\n    return pathOrUrl;\n  const fixedPath = trailingSlash ? withTrailingSlash($url.pathname) : withoutTrailingSlash($url.pathname);\n  return `${$url.protocol ? `${$url.protocol}//` : \"\"}${$url.host || \"\"}${fixedPath}${$url.search || \"\"}${$url.hash || \"\"}`;\n}\n\nexport { fixSlashes, isPathFile, resolveSitePath };\n","import { useRequestEvent } from \"#app\";\nexport function useNitroOrigin(e) {\n  if (import.meta.server) {\n    e = e || useRequestEvent();\n    return e?.context?.siteConfigNitroOrigin || \"\";\n  }\n  return window.location.origin;\n}\n","import { useRuntimeConfig } from \"#app\";\nimport { fixSlashes, resolveSitePath } from \"site-config-stack/urls\";\nimport { computed, unref } from \"vue\";\nimport { useNitroOrigin } from \"./useNitroOrigin.js\";\nimport { useSiteConfig } from \"./useSiteConfig.js\";\nexport function createSitePathResolver(options = {}) {\n  const siteConfig = useSiteConfig();\n  const nitroOrigin = useNitroOrigin();\n  const nuxtBase = useRuntimeConfig().app.baseURL || \"/\";\n  return (path) => {\n    return computed(() => resolveSitePath(unref(path), {\n      absolute: unref(options.absolute),\n      withBase: unref(options.withBase),\n      siteUrl: unref(options.canonical) !== false || import.meta.prerender ? siteConfig.url : nitroOrigin,\n      trailingSlash: siteConfig.trailingSlash,\n      base: nuxtBase\n    }));\n  };\n}\nexport function withSiteTrailingSlash(path) {\n  const siteConfig = useSiteConfig();\n  return computed(() => fixSlashes(siteConfig.trailingSlash, unref(path)));\n}\nexport function withSiteUrl(path, options = {}) {\n  const siteConfig = useSiteConfig();\n  const nitroOrigin = useNitroOrigin();\n  const base = useRuntimeConfig().app.baseURL || \"/\";\n  return computed(() => {\n    return resolveSitePath(unref(path), {\n      absolute: true,\n      siteUrl: unref(options.canonical) !== false || import.meta.prerender ? siteConfig.url : nitroOrigin,\n      trailingSlash: siteConfig.trailingSlash,\n      base,\n      withBase: unref(options.withBase)\n    });\n  });\n}\n","import { useSiteConfig } from \"#site-config/app/composables/useSiteConfig\";\nimport { defineWebPage, defineWebSite } from \"@unhead/schema-org/vue\";\nimport { defineNuxtPlugin } from \"nuxt/app\";\nimport { useSchemaOrg } from \"../composables/useSchemaOrg.js\";\nimport { maybeAddIdentitySchemaOrg } from \"../utils/shared.js\";\nexport default defineNuxtPlugin({\n  name: \"nuxt-schema-org:defaults\",\n  dependsOn: [\n    \"nuxt-schema-org:init\"\n  ],\n  setup() {\n    const siteConfig = useSiteConfig();\n    useSchemaOrg([\n      defineWebSite({\n        name: siteConfig?.name || \"\",\n        inLanguage: siteConfig?.currentLocale || \"\",\n        description: siteConfig?.description || \"\"\n      }),\n      defineWebPage()\n    ]);\n    maybeAddIdentitySchemaOrg();\n  }\n});\n","export const componentNames = [{\"hash\":\"ZNBt6OzdC-VxkzqSV9SuTiHsJ6IbLY4McPj8Axz1kio\",\"pascalName\":\"OgImageTemplate\",\"kebabName\":\"og-image-template\",\"path\":\"/home/river/Projects/oc/nclinic.cz/app/components/OgImageTemplate.vue\",\"category\":\"app\"},{\"hash\":\"lqi2TIJIQMafRl6atyAjEmgaOb13hjqfbfUGe7PXhOw\",\"pascalName\":\"BrandedLogoDVue\",\"kebabName\":\"branded-logo-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/BrandedLogo.d.vue.ts\",\"category\":\"community\",\"credits\":\"Full Stack Heroes <https://fullstackheroes.com/>\"},{\"hash\":\"SOHaoKfoo4fUkREsCFGw8ewxkl4-XkkHkug2VwYRtFM\",\"pascalName\":\"BrandedLogo\",\"kebabName\":\"branded-logo\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/BrandedLogo.vue\",\"category\":\"community\"},{\"hash\":\"BMTMwASJKH3AG9ey0Y845iqbPNO7HjNX5eW2U2psVTE\",\"pascalName\":\"FrameDVue\",\"kebabName\":\"frame-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Frame.d.vue.ts\",\"category\":\"community\",\"credits\":\"@arashsheyda <https://github.com/arashsheyda>\"},{\"hash\":\"tFoYPh0fXaZR3uXybAqFEOGnQuQsvz-E-Yq-CtrFlIY\",\"pascalName\":\"Frame\",\"kebabName\":\"frame\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Frame.vue\",\"category\":\"community\"},{\"hash\":\"XHXMYyA3oPy1eN81p4R-wv8k8tkHNooxhCRL8Zs1Pz0\",\"pascalName\":\"NuxtDVue\",\"kebabName\":\"nuxt-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Nuxt.d.vue.ts\",\"category\":\"community\"},{\"hash\":\"NPQTTXYQ8toXx5OaJ1VlRUUcxy1SNOxg-FoM7C08ZPM\",\"pascalName\":\"Nuxt\",\"kebabName\":\"nuxt\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Nuxt.vue\",\"category\":\"community\"},{\"hash\":\"jGeID02J5-Tz9qaGIsRVZfJSXVQS9q-3V2Qnw65GQMg\",\"pascalName\":\"NuxtSeoDVue\",\"kebabName\":\"nuxt-seo-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/NuxtSeo.d.vue.ts\",\"category\":\"community\"},{\"hash\":\"VAHSTZlVcPHzkozocV1iTnwc4-YttdoOkHsYfoSgDZ4\",\"pascalName\":\"NuxtSeo\",\"kebabName\":\"nuxt-seo\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/NuxtSeo.vue\",\"category\":\"community\"},{\"hash\":\"XHXMYyA3oPy1eN81p4R-wv8k8tkHNooxhCRL8Zs1Pz0\",\"pascalName\":\"PergelDVue\",\"kebabName\":\"pergel-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Pergel.d.vue.ts\",\"category\":\"community\"},{\"hash\":\"8CNn4yU043gQFqO-sZNDPz9GKED-h7ahXJ-61c9ThHM\",\"pascalName\":\"Pergel\",\"kebabName\":\"pergel\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Pergel.vue\",\"category\":\"community\"},{\"hash\":\"7-N5uiZ77GftW16gAKUKdbC2kTqoiWjlYDsNWxCsCG4\",\"pascalName\":\"SimpleBlogDVue\",\"kebabName\":\"simple-blog-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/SimpleBlog.d.vue.ts\",\"category\":\"community\"},{\"hash\":\"b-Juo-FXQepo6SOCnA478MTAqbXNZuve6-MzHgTKA7s\",\"pascalName\":\"SimpleBlog\",\"kebabName\":\"simple-blog\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/SimpleBlog.vue\",\"category\":\"community\"},{\"hash\":\"ahhiG3dVaeRX0C50qOnvcUsjBRro4ufe-6jzsUbVxBY\",\"pascalName\":\"UnJsDVue\",\"kebabName\":\"un-js-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/UnJs.d.vue.ts\",\"category\":\"community\",\"credits\":\"UnJS <https://unjs.io/>\"},{\"hash\":\"vRUm5ru-64PEHIGsBby6-vCgLBg7iUJfvFKL6VuCXtI\",\"pascalName\":\"UnJs\",\"kebabName\":\"un-js\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/UnJs.vue\",\"category\":\"community\"},{\"hash\":\"pzp5dWaNkZa2Gbj-RXhoDiBahvrINMjPJC9-Vs2OtxE\",\"pascalName\":\"WaveDVue\",\"kebabName\":\"wave-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Wave.d.vue.ts\",\"category\":\"community\",\"credits\":\"Full Stack Heroes <https://fullstackheroes.com/>\"},{\"hash\":\"hq07GBU-Yd16ICfETt8SfSxfaYj3qBmDAiQkTcv89nw\",\"pascalName\":\"Wave\",\"kebabName\":\"wave\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/Wave.vue\",\"category\":\"community\"},{\"hash\":\"hsZbjduIx-cfHCcgbOY44VlwFWt5bfWv-VxiGiUifDs\",\"pascalName\":\"WithEmojiDVue\",\"kebabName\":\"with-emoji-d-vue\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/WithEmoji.d.vue.ts\",\"category\":\"community\",\"credits\":\"Full Stack Heroes <https://fullstackheroes.com/>\"},{\"hash\":\"zSwOodBXcjwS1qvFqGBJqitTEEnrvVfwQYkTeIxNpws\",\"pascalName\":\"WithEmoji\",\"kebabName\":\"with-emoji\",\"path\":\"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/components/Templates/Community/WithEmoji.vue\",\"category\":\"community\"}]","import { defu } from \"defu\";\nimport { toValue } from \"vue\";\nexport function generateMeta(url, resolvedOptions) {\n  const meta = [\n    { property: \"og:image\", content: url },\n    { property: \"og:image:type\", content: () => `image/${getExtension(toValue(url)) || resolvedOptions.extension}` },\n    { name: \"twitter:card\", content: \"summary_large_image\" },\n    // we don't need this but avoids issue when using useSeoMeta({ twitterImage })\n    { name: \"twitter:image\", content: url },\n    { name: \"twitter:image:src\", content: url }\n  ];\n  if (resolvedOptions.width) {\n    meta.push({ property: \"og:image:width\", content: resolvedOptions.width });\n    meta.push({ name: \"twitter:image:width\", content: resolvedOptions.width });\n  }\n  if (resolvedOptions.height) {\n    meta.push({ property: \"og:image:height\", content: resolvedOptions.height });\n    meta.push({ name: \"twitter:image:height\", content: resolvedOptions.height });\n  }\n  if (resolvedOptions.alt) {\n    meta.push({ property: \"og:image:alt\", content: resolvedOptions.alt });\n    meta.push({ name: \"twitter:image:alt\", content: resolvedOptions.alt });\n  }\n  return meta;\n}\nfunction detectBase64MimeType(data) {\n  const signatures = {\n    \"R0lGODdh\": \"image/gif\",\n    \"R0lGODlh\": \"image/gif\",\n    \"iVBORw0KGgo\": \"image/png\",\n    \"/9j/\": \"image/jpeg\",\n    \"UklGR\": \"image/webp\",\n    \"AAABAA\": \"image/x-icon\"\n  };\n  for (const s in signatures) {\n    if (data.startsWith(s)) {\n      return signatures[s];\n    }\n  }\n  return \"image/svg+xml\";\n}\nexport function toBase64Image(data) {\n  const base64 = typeof data === \"string\" ? data : Buffer.from(data).toString(\"base64\");\n  const type = detectBase64MimeType(base64);\n  return `data:${type};base64,${base64}`;\n}\nexport function isInternalRoute(path) {\n  return path.startsWith(\"/_\") || path.startsWith(\"@\");\n}\nfunction filterIsOgImageOption(key) {\n  const keys = [\n    \"url\",\n    \"extension\",\n    \"width\",\n    \"height\",\n    \"fonts\",\n    \"alt\",\n    \"props\",\n    \"renderer\",\n    \"html\",\n    \"component\",\n    \"renderer\",\n    \"emojis\",\n    \"_query\",\n    \"satori\",\n    \"resvg\",\n    \"sharp\",\n    \"screenshot\",\n    \"cacheMaxAgeSeconds\"\n  ];\n  return keys.includes(key);\n}\nexport function separateProps(options, ignoreKeys = []) {\n  options = options || {};\n  const _props = defu(options.props, Object.fromEntries(\n    Object.entries({ ...options }).filter(([k]) => !filterIsOgImageOption(k) && !ignoreKeys.includes(k))\n  ));\n  const props = {};\n  Object.entries(_props).forEach(([key, val]) => {\n    props[key.replace(/-([a-z])/g, (g) => String(g[1]).toUpperCase())] = val;\n  });\n  return {\n    ...Object.fromEntries(\n      Object.entries({ ...options }).filter(([k]) => filterIsOgImageOption(k) || ignoreKeys.includes(k))\n    ),\n    props\n  };\n}\nexport function normaliseFontInput(fonts) {\n  return fonts.map((f) => {\n    if (typeof f === \"string\") {\n      const vals = f.split(\":\");\n      const includesStyle = vals.length === 3;\n      let name, weight, style;\n      if (includesStyle) {\n        name = vals[0];\n        style = vals[1];\n        weight = vals[2];\n      } else {\n        name = vals[0];\n        weight = vals[1];\n      }\n      return {\n        cacheKey: f,\n        name,\n        weight: weight || 400,\n        style: style || \"normal\",\n        path: void 0\n      };\n    }\n    return {\n      cacheKey: f.key || `${f.name}:${f.style}:${f.weight}`,\n      style: \"normal\",\n      weight: 400,\n      ...f\n    };\n  });\n}\nexport function withoutQuery(path) {\n  return path.split(\"?\")[0];\n}\nexport function getExtension(path) {\n  path = withoutQuery(path);\n  const lastSegment = path.split(\"/\").pop() || path;\n  const extension = lastSegment.split(\".\").pop() || lastSegment;\n  if (extension === \"jpg\")\n    return \"jpeg\";\n  return extension;\n}\nexport function useOgImageRuntimeConfig() {\n  return {};\n}\n","import { componentNames } from \"#build/nuxt-og-image/components.mjs\";\nimport { resolveUnrefHeadInput } from \"@unhead/vue\";\nimport { defu } from \"defu\";\nimport { stringify } from \"devalue\";\nimport { useHead, useRuntimeConfig } from \"nuxt/app\";\nimport { joinURL, withQuery } from \"ufo\";\nimport { generateMeta, separateProps } from \"../shared.js\";\nexport function setHeadOgImagePrebuilt(input) {\n  if (import.meta.client) {\n    return;\n  }\n  const url = input.url;\n  if (!url)\n    return;\n  const meta = generateMeta(url, input);\n  useHead({ meta }, { tagPriority: \"high\" });\n}\nexport function createOgImageMeta(src, input, ssrContext) {\n  if (import.meta.client) {\n    return;\n  }\n  const { defaults } = useOgImageRuntimeConfig();\n  const _input = separateProps(defu(input, ssrContext._ogImagePayload));\n  if (input._query && Object.keys(input._query).length)\n    src = withQuery(src, { _query: input._query });\n  const meta = generateMeta(src, input);\n  ssrContext._ogImageInstances = ssrContext._ogImageInstances || [];\n  const script = [];\n  if (src) {\n    script.push({\n      id: \"nuxt-og-image-options\",\n      type: \"application/json\",\n      processTemplateParams: true,\n      innerHTML: () => {\n        const payload = resolveUnrefHeadInput(_input);\n        if (payload.props && typeof payload.props.title === \"undefined\")\n          payload.props.title = \"%s\";\n        payload.component = resolveComponentName(input.component, defaults.component || \"\");\n        delete payload.url;\n        if (payload._query && Object.keys(payload._query).length === 0) {\n          delete payload._query;\n        }\n        const final = {};\n        for (const k in payload) {\n          if (payload[k] !== defaults[k]) {\n            final[k] = payload[k];\n          }\n        }\n        return stringify(final);\n      },\n      // we want this to be last in our head\n      tagPosition: \"bodyClose\"\n    });\n  }\n  const instance = useHead({\n    script,\n    meta\n  }, {\n    tagPriority: \"high\"\n  });\n  ssrContext._ogImagePayload = _input;\n  ssrContext._ogImageInstances.push(instance);\n}\nexport function resolveComponentName(component, fallback) {\n  component = component || fallback || componentNames?.[0]?.pascalName;\n  if (component && componentNames) {\n    const originalName = component;\n    for (const component2 of componentNames) {\n      if (component2.pascalName.endsWith(originalName) || component2.kebabName.endsWith(originalName)) {\n        return component2.pascalName;\n      }\n    }\n  }\n  return component;\n}\nexport function getOgImagePath(pagePath, _options) {\n  const baseURL = useRuntimeConfig().app.baseURL;\n  const extension = _options?.extension || useOgImageRuntimeConfig().defaults?.extension || \"png\";\n  const path = joinURL(\"/\", baseURL, `__og-image__/${import.meta.prerender ? \"static\" : \"image\"}`, pagePath, `og.${extension}`);\n  if (Object.keys(_options?._query || {}).length) {\n    return withQuery(path, _options._query);\n  }\n  return path;\n}\nexport function useOgImageRuntimeConfig() {\n  const c = useRuntimeConfig();\n  return {\n    defaults: {},\n    ...c[\"nuxt-og-image\"],\n    app: {\n      baseURL: c.app.baseURL\n    }\n  };\n}\n","import { joinURL } from \"ufo\";\nimport { createRouter as createRadixRouter, toRouteMatcher } from \"radix3\";\nimport defu from \"defu\";\nimport { defineNuxtPlugin, useRuntimeConfig } from \"#app/nuxt\";\nimport { prerenderRoutes } from \"#app/composables/ssr\";\nimport _routes from \"#build/routes\";\nimport routerOptions, { hashMode } from \"#build/router.options\";\nimport { crawlLinks } from \"#build/nuxt.config.mjs\";\nlet routes;\nlet _routeRulesMatcher = void 0;\nexport default defineNuxtPlugin(async () => {\n  if (!import.meta.server || !import.meta.prerender || hashMode) {\n    return;\n  }\n  if (routes && !routes.length) {\n    return;\n  }\n  const routeRules = useRuntimeConfig().nitro.routeRules;\n  if (!crawlLinks && routeRules && Object.values(routeRules).some((r) => r.prerender)) {\n    _routeRulesMatcher = toRouteMatcher(createRadixRouter({ routes: routeRules }));\n  }\n  routes ||= Array.from(processRoutes(await routerOptions.routes?.(_routes) ?? _routes));\n  const batch = routes.splice(0, 10);\n  prerenderRoutes(batch);\n});\nconst OPTIONAL_PARAM_RE = /^\\/?:.*(?:\\?|\\(\\.\\*\\)\\*)$/;\nfunction shouldPrerender(path) {\n  return !_routeRulesMatcher || defu({}, ..._routeRulesMatcher.matchAll(path).reverse()).prerender;\n}\nfunction processRoutes(routes2, currentPath = \"/\", routesToPrerender = /* @__PURE__ */ new Set()) {\n  for (const route of routes2) {\n    if (OPTIONAL_PARAM_RE.test(route.path) && !route.children?.length && shouldPrerender(currentPath)) {\n      routesToPrerender.add(currentPath);\n    }\n    if (route.path.includes(\":\")) {\n      continue;\n    }\n    const fullPath = joinURL(currentPath, route.path);\n    if (shouldPrerender(fullPath)) {\n      routesToPrerender.add(fullPath);\n    }\n    if (route.children) {\n      processRoutes(route.children, fullPath, routesToPrerender);\n    }\n  }\n  return routesToPrerender;\n}\n","import unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt/dist/head/runtime/plugins/unhead.js\";\nimport router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt/dist/pages/runtime/plugins/router.js\";\nimport _0_siteConfig_tU0SxKrPeVRXWcGu2sOnIfhNDbYiKNfDCvYZhRueG0Q from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-site-config/dist/runtime/app/plugins/0.siteConfig.js\";\nimport revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt/dist/app/plugins/revive-payload.server.js\";\nimport components_plugin_4kY4pyzJIYX99vmMAAIorFf3CnAaptHitJgf7JxiED8 from \"/home/river/Projects/oc/nclinic.cz/node_modules/.cache/nuxt/.nuxt/components.plugin.mjs\";\nimport defaults_ZjgoYqsIrjWNaJMfDhci2B0eoNnvY4CDsoscm0L1fE0 from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-schema-org/dist/runtime/app/plugins/defaults.js\";\nimport init_Ks1wcI1vuv3K3FXG7iAYRqIWlPli19G_eByed0tsXe0 from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-schema-org/dist/runtime/app/plugins/init.js\";\nimport robot_meta_server_bRHpso_4KN_Ec3RJzqCvbuvfZsNOeE_4TgpL8dCNuwk from \"/home/river/Projects/oc/nclinic.cz/node_modules/@nuxtjs/robots/dist/runtime/app/plugins/robot-meta.server.js\";\nimport og_image_canonical_urls_server_2uCBKzWxjEK91fSFBdBNPEWilWXRzR66cHJvjIi4FGA from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/plugins/og-image-canonical-urls.server.js\";\nimport route_rule_og_image_server_yrHfzNQxtCKZyHaGhWqsbaa4V0Y5WoBOo3_wqkmh41k from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt-og-image/dist/runtime/app/plugins/route-rule-og-image.server.js\";\nimport prerender_server_sqIxOBipVr4FbVMA9kqWL0wT8FPop6sKAXLVfifsJzk from \"/home/river/Projects/oc/nclinic.cz/node_modules/nuxt/dist/pages/runtime/plugins/prerender.server.js\";\nexport default [\n  unhead_k2P3m_ZDyjlr2mMYnoDPwavjsDN8hBlk9cFai0bbopU,\n  router_GNCWhvtYfLTYRZZ135CdFAEjxdMexN0ixiUYCAN_tpw,\n  _0_siteConfig_tU0SxKrPeVRXWcGu2sOnIfhNDbYiKNfDCvYZhRueG0Q,\n  revive_payload_server_MVtmlZaQpj6ApFmshWfUWl5PehCebzaBf2NuRMiIbms,\n  components_plugin_4kY4pyzJIYX99vmMAAIorFf3CnAaptHitJgf7JxiED8,\n  defaults_ZjgoYqsIrjWNaJMfDhci2B0eoNnvY4CDsoscm0L1fE0,\n  init_Ks1wcI1vuv3K3FXG7iAYRqIWlPli19G_eByed0tsXe0,\n  robot_meta_server_bRHpso_4KN_Ec3RJzqCvbuvfZsNOeE_4TgpL8dCNuwk,\n  og_image_canonical_urls_server_2uCBKzWxjEK91fSFBdBNPEWilWXRzR66cHJvjIi4FGA,\n  route_rule_og_image_server_yrHfzNQxtCKZyHaGhWqsbaa4V0Y5WoBOo3_wqkmh41k,\n  prerender_server_sqIxOBipVr4FbVMA9kqWL0wT8FPop6sKAXLVfifsJzk\n]","\nimport { defineNuxtPlugin } from '#app/nuxt'\nexport default defineNuxtPlugin({\n  name: 'nuxt:global-components',\n})\n","import {\n  useSiteConfig\n} from \"#site-config/app/composables/useSiteConfig\";\nimport { createSitePathResolver } from \"#site-config/app/composables/utils\";\nimport { SchemaOrgUnheadPlugin } from \"@unhead/schema-org/vue\";\nimport { injectHead } from \"@unhead/vue\";\nimport { defu } from \"defu\";\nimport { useRoute } from \"nuxt/app\";\nimport { camelCase } from \"scule\";\nimport { withoutTrailingSlash } from \"ufo\";\nimport { computed } from \"vue\";\nimport { useSchemaOrg } from \"../composables/useSchemaOrg.js\";\nimport { useSchemaOrgConfig } from \"./config.js\";\nexport function initPlugin(nuxtApp) {\n  const head = injectHead();\n  const config = useSchemaOrgConfig();\n  const route = useRoute();\n  const siteConfig = useSiteConfig();\n  const resolvePath = createSitePathResolver({\n    absolute: false,\n    withBase: true\n  });\n  const resolveUrl = createSitePathResolver({\n    canonical: true,\n    absolute: true,\n    withBase: true\n  });\n  const schemaOrg = computed(() => {\n    return {\n      ...route.meta?.schemaOrg || {},\n      ...siteConfig,\n      url: resolveUrl(route.path),\n      host: withoutTrailingSlash(siteConfig.url),\n      inLanguage: siteConfig.currentLocale || siteConfig.defaultLocale,\n      path: resolvePath(route.path)\n    };\n  });\n  head.push({ templateParams: { schemaOrg } });\n  head.use(\n    SchemaOrgUnheadPlugin({}, async () => {\n      const meta = {};\n      await nuxtApp.hooks.callHook(\"schema-org:meta\", meta);\n      return meta;\n    }, {\n      minify: config.minify,\n      trailingSlash: siteConfig.trailingSlash\n    })\n  );\n}\nexport function maybeAddIdentitySchemaOrg() {\n  const config = useSchemaOrgConfig();\n  const siteConfig = useSiteConfig();\n  if (config.identity || siteConfig.identity) {\n    const identity = config.identity || siteConfig.identity;\n    let identityPayload = {\n      name: siteConfig.name,\n      url: siteConfig.url\n    };\n    let identityType;\n    if (typeof identity !== \"string\") {\n      identityPayload = defu(identity, identityPayload);\n      identityType = identity.type;\n      delete identityPayload.type;\n    } else {\n      identityType = identity;\n    }\n    if (siteConfig.twitter) {\n      const id = siteConfig.twitter.startsWith(\"@\") ? siteConfig.twitter.slice(1) : siteConfig.twitter;\n      identityPayload.sameAs = [\n        `https://twitter.com/${id}`\n      ];\n    }\n    identityPayload._resolver = identityPayload._resolver || camelCase(identityType);\n    useSchemaOrg([identityPayload]);\n  }\n}\n","import { defineNuxtPlugin } from \"nuxt/app\";\nimport { initPlugin } from \"../utils/shared.js\";\nexport default defineNuxtPlugin({\n  name: \"nuxt-schema-org:init\",\n  setup(nuxtApp) {\n    initPlugin(nuxtApp);\n  }\n});\n","import { useHead } from \"#imports\";\nimport { defineNuxtPlugin, useRequestEvent } from \"nuxt/app\";\nexport default defineNuxtPlugin({\n  setup() {\n    const event = useRequestEvent();\n    const ctx = event?.context?.robots;\n    if (!ctx)\n      return;\n    useHead({\n      meta: [\n        {\n          \"name\": \"robots\",\n          \"content\": () => ctx.rule || \"\",\n          \"data-hint\": () => import.meta.dev && ctx.debug?.source ? [ctx.debug?.source, ctx.debug?.line].filter(Boolean).join(\",\") : void 0\n        }\n      ]\n    });\n  }\n});\n","import { defineNuxtPlugin } from \"#app\";\nimport { ogImageCanonicalUrls as setup } from \"../utils/plugins.js\";\nexport default defineNuxtPlugin({\n  setup(nuxtApp) {\n    setup(nuxtApp);\n  }\n});\n","import { useRequestEvent } from \"#app\";\nimport { withSiteUrl } from \"#site-config/app/composables\";\nimport { TemplateParamsPlugin } from \"@unhead/vue/plugins\";\nimport { defu } from \"defu\";\nimport { parse, stringify } from \"devalue\";\nimport { createRouter as createRadixRouter, toRouteMatcher } from \"radix3\";\nimport { parseURL, withoutBase } from \"ufo\";\nimport { toValue } from \"vue\";\nimport { createOgImageMeta } from \"../../app/utils.js\";\nimport { isInternalRoute, separateProps } from \"../../shared.js\";\nimport { getOgImagePath } from \"../utils.js\";\nexport function ogImageCanonicalUrls(nuxtApp) {\n  nuxtApp.hooks.hook(\"app:rendered\", async (ctx) => {\n    const { ssrContext } = ctx;\n    const e = useRequestEvent();\n    const path = parseURL(e?.path || \"\").pathname;\n    if (isInternalRoute(path))\n      return;\n    ssrContext?.head.use(TemplateParamsPlugin);\n    ssrContext?.head.use({\n      key: \"nuxt-og-image:overrides-and-canonical-urls\",\n      hooks: {\n        \"tags:resolve\": async (ctx2) => {\n          const hasPrimaryPayload = ctx2.tags.some((tag) => tag.tag === \"script\" && tag.props.id === \"nuxt-og-image-options\");\n          let overrides;\n          for (const tag of ctx2.tags) {\n            if (tag.tag === \"script\" && tag.props.id === \"nuxt-og-image-overrides\") {\n              if (hasPrimaryPayload) {\n                overrides = separateProps(parse(tag.innerHTML || \"{}\"));\n                delete ctx2.tags[ctx2.tags.indexOf(tag)];\n              } else {\n                tag.props.id = \"nuxt-og-image-options\";\n                tag.innerHTML = stringify(separateProps(parse(tag.innerHTML || \"{}\")));\n                tag._d = \"script:id:nuxt-og-image-options\";\n              }\n              break;\n            }\n          }\n          ctx2.tags = ctx2.tags.filter(Boolean);\n          for (const tag of ctx2.tags) {\n            if (tag.tag === \"meta\" && (tag.props.property === \"og:image\" || [\"twitter:image:src\", \"twitter:image\"].includes(tag.props.name || \"\"))) {\n              if (!tag.props.content) {\n                tag.props = {};\n                continue;\n              }\n              if (!tag.props.content?.startsWith(\"https\")) {\n                await nuxtApp.runWithContext(() => {\n                  tag.props.content = toValue(withSiteUrl(tag.props.content || \"\", {\n                    withBase: true\n                  }));\n                });\n              }\n            } else if (overrides && tag.tag === \"script\" && tag.props.id === \"nuxt-og-image-options\") {\n              tag.innerHTML = stringify(defu(overrides, parse(tag.innerHTML || \"{}\")));\n            }\n          }\n        }\n      }\n    });\n  });\n}\nexport function routeRuleOgImage(nuxtApp) {\n  nuxtApp.hooks.hook(\"app:rendered\", async (ctx) => {\n    const { ssrContext } = ctx;\n    const e = useRequestEvent();\n    const path = parseURL(e?.path || \"\").pathname;\n    if (isInternalRoute(path))\n      return;\n    const _routeRulesMatcher = toRouteMatcher(\n      createRadixRouter({ routes: ssrContext?.runtimeConfig?.nitro?.routeRules })\n    );\n    const matchedRules = _routeRulesMatcher.matchAll(\n      withoutBase(path.split(\"?\")?.[0] || \"\", ssrContext?.runtimeConfig?.app.baseURL || \"\")\n    ).reverse();\n    const combinedRules = defu({}, ...matchedRules);\n    let routeRules = combinedRules?.ogImage;\n    if (typeof routeRules === \"undefined\")\n      return;\n    const ogImageInstances = nuxtApp.ssrContext._ogImageInstances || [];\n    if (routeRules === false) {\n      ogImageInstances?.forEach((e2) => {\n        e2.dispose();\n      });\n      nuxtApp.ssrContext._ogImagePayload = void 0;\n      nuxtApp.ssrContext._ogImageInstances = void 0;\n      return;\n    }\n    routeRules = defu(nuxtApp.ssrContext?.event?.context._nitro?.routeRules?.ogImage, routeRules);\n    const src = getOgImagePath(ssrContext.url, routeRules);\n    createOgImageMeta(src, routeRules, nuxtApp.ssrContext);\n  });\n}\n","import { defineNuxtPlugin } from \"#app\";\nimport { routeRuleOgImage as setup } from \"../utils/plugins.js\";\nexport default defineNuxtPlugin({\n  setup(nuxtApp) {\n    setup(nuxtApp);\n  }\n});\n","import { defineAsyncComponent } from 'vue'\nexport default {\n  default: defineAsyncComponent(() => import(\"/home/river/Projects/oc/nclinic.cz/app/layouts/default.vue\").then(m => m.default || m))\n}","import { Suspense, computed, defineComponent, h, inject, mergeProps, nextTick, onMounted, provide, shallowReactive, shallowRef, unref } from \"vue\";\nimport { useRoute, useRouter } from \"../composables/router.js\";\nimport { useNuxtApp } from \"../nuxt.js\";\nimport { _wrapInTransition } from \"./utils.js\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"./injections.js\";\nimport { useRoute as useVueRouterRoute } from \"#build/pages\";\nimport layouts from \"#build/layouts\";\nimport { appLayoutTransition as defaultLayoutTransition } from \"#build/nuxt.config.mjs\";\nconst LayoutLoader = defineComponent({\n  name: \"LayoutLoader\",\n  inheritAttrs: false,\n  props: {\n    name: String,\n    layoutProps: Object\n  },\n  setup(props, context) {\n    return () => h(layouts[props.name], props.layoutProps, context.slots);\n  }\n});\nconst nuxtLayoutProps = {\n  name: {\n    type: [String, Boolean, Object],\n    default: null\n  },\n  fallback: {\n    type: [String, Object],\n    default: null\n  }\n};\nexport default defineComponent({\n  name: \"NuxtLayout\",\n  inheritAttrs: false,\n  props: nuxtLayoutProps,\n  setup(props, context) {\n    const nuxtApp = useNuxtApp();\n    const injectedRoute = inject(PageRouteSymbol);\n    const shouldUseEagerRoute = !injectedRoute || injectedRoute === useRoute();\n    const route = shouldUseEagerRoute ? useVueRouterRoute() : injectedRoute;\n    const layout = computed(() => {\n      let layout2 = unref(props.name) ?? route?.meta.layout ?? \"default\";\n      if (layout2 && !(layout2 in layouts)) {\n        if (import.meta.dev && layout2 !== \"default\") {\n          console.warn(`Invalid layout \\`${layout2}\\` selected.`);\n        }\n        if (props.fallback) {\n          layout2 = unref(props.fallback);\n        }\n      }\n      return layout2;\n    });\n    const layoutRef = shallowRef();\n    context.expose({ layoutRef });\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtLayoutUsed = true;\n    }\n    let lastLayout;\n    return () => {\n      const hasLayout = layout.value && layout.value in layouts;\n      const transitionProps = route?.meta.layoutTransition ?? defaultLayoutTransition;\n      const previouslyRenderedLayout = lastLayout;\n      lastLayout = layout.value;\n      return _wrapInTransition(hasLayout && transitionProps, {\n        default: () => h(Suspense, { suspensible: true, onResolve: () => {\n          nextTick(done);\n        } }, {\n          default: () => h(\n            LayoutProvider,\n            {\n              layoutProps: mergeProps(context.attrs, { ref: layoutRef }),\n              key: layout.value || void 0,\n              name: layout.value,\n              shouldProvide: !props.name,\n              isRenderingNewLayout: (name) => {\n                return name !== previouslyRenderedLayout && name === layout.value;\n              },\n              hasTransition: !!transitionProps\n            },\n            context.slots\n          )\n        })\n      }).default();\n    };\n  }\n});\nconst LayoutProvider = defineComponent({\n  name: \"NuxtLayoutProvider\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: [String, Boolean]\n    },\n    layoutProps: {\n      type: Object\n    },\n    hasTransition: {\n      type: Boolean\n    },\n    shouldProvide: {\n      type: Boolean\n    },\n    isRenderingNewLayout: {\n      type: Function,\n      required: true\n    }\n  },\n  setup(props, context) {\n    const name = props.name;\n    if (props.shouldProvide) {\n      provide(LayoutMetaSymbol, {\n        isCurrent: (route) => name === (route.meta.layout ?? \"default\")\n      });\n    }\n    const injectedRoute = inject(PageRouteSymbol);\n    const isNotWithinNuxtPage = injectedRoute && injectedRoute === useRoute();\n    if (isNotWithinNuxtPage) {\n      const vueRouterRoute = useVueRouterRoute();\n      const reactiveChildRoute = {};\n      for (const _key in vueRouterRoute) {\n        const key = _key;\n        Object.defineProperty(reactiveChildRoute, key, {\n          enumerable: true,\n          get: () => {\n            return props.isRenderingNewLayout(props.name) ? vueRouterRoute[key] : injectedRoute[key];\n          }\n        });\n      }\n      provide(PageRouteSymbol, shallowReactive(reactiveChildRoute));\n    }\n    let vnode;\n    if (import.meta.dev && import.meta.client) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            if (name) {\n              console.warn(`[nuxt] \\`${name}\\` layout does not have a single root node and will cause errors when navigating between routes.`);\n            } else {\n              console.warn(\"[nuxt] `<NuxtLayout>` needs to be passed a single root node in its default slot.\");\n            }\n          }\n        });\n      });\n    }\n    return () => {\n      if (!name || typeof name === \"string\" && !(name in layouts)) {\n        if (import.meta.dev && import.meta.client && props.hasTransition) {\n          vnode = context.slots.default?.();\n          return vnode;\n        }\n        return context.slots.default?.();\n      }\n      if (import.meta.dev && import.meta.client && props.hasTransition) {\n        vnode = h(\n          LayoutLoader,\n          { key: name, layoutProps: props.layoutProps, name },\n          context.slots\n        );\n        return vnode;\n      }\n      return h(\n        LayoutLoader,\n        { key: name, layoutProps: props.layoutProps, name },\n        context.slots\n      );\n    };\n  }\n});\n","import { defineComponent, h, nextTick, onMounted, provide, shallowReactive } from \"vue\";\nimport { PageRouteSymbol } from \"./injections.js\";\nexport const defineRouteProvider = (name = \"RouteProvider\") => defineComponent({\n  name,\n  props: {\n    route: {\n      type: Object,\n      required: true\n    },\n    vnode: Object,\n    vnodeRef: Object,\n    renderKey: String,\n    trackRootNodes: Boolean\n  },\n  setup(props) {\n    const previousKey = props.renderKey;\n    const previousRoute = props.route;\n    const route = {};\n    for (const key in props.route) {\n      Object.defineProperty(route, key, {\n        get: () => previousKey === props.renderKey ? props.route[key] : previousRoute[key],\n        enumerable: true\n      });\n    }\n    provide(PageRouteSymbol, shallowReactive(route));\n    let vnode;\n    if (import.meta.dev && import.meta.client && props.trackRootNodes) {\n      onMounted(() => {\n        nextTick(() => {\n          if ([\"#comment\", \"#text\"].includes(vnode?.el?.nodeName)) {\n            const filename = vnode?.type?.__file;\n            console.warn(`[nuxt] \\`${filename}\\` does not have a single root node and will cause errors when navigating between routes.`);\n          }\n        });\n      });\n    }\n    return () => {\n      if (!props.vnode) {\n        return props.vnode;\n      }\n      if (import.meta.dev && import.meta.client) {\n        vnode = h(props.vnode, { ref: props.vnodeRef });\n        return vnode;\n      }\n      return h(props.vnode, { ref: props.vnodeRef });\n    };\n  }\n});\nexport const RouteProvider = defineRouteProvider();\n","import { Fragment, Suspense, defineComponent, h, inject, nextTick, onBeforeUnmount, ref, watch } from \"vue\";\nimport { RouterView } from \"vue-router\";\nimport { defu } from \"defu\";\nimport { generateRouteKey, toArray, wrapInKeepAlive } from \"./utils.js\";\nimport { RouteProvider, defineRouteProvider } from \"#app/components/route-provider\";\nimport { useNuxtApp } from \"#app/nuxt\";\nimport { useRouter } from \"#app/composables/router\";\nimport { _wrapInTransition } from \"#app/components/utils\";\nimport { LayoutMetaSymbol, PageRouteSymbol } from \"#app/components/injections\";\nimport { appKeepalive as defaultKeepaliveConfig, appPageTransition as defaultPageTransition } from \"#build/nuxt.config.mjs\";\nconst _routeProviders = import.meta.dev ? /* @__PURE__ */ new Map() : /* @__PURE__ */ new WeakMap();\nexport default defineComponent({\n  name: \"NuxtPage\",\n  inheritAttrs: false,\n  props: {\n    name: {\n      type: String\n    },\n    transition: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    keepalive: {\n      type: [Boolean, Object],\n      default: void 0\n    },\n    route: {\n      type: Object\n    },\n    pageKey: {\n      type: [Function, String],\n      default: null\n    }\n  },\n  setup(props, { attrs, slots, expose }) {\n    const nuxtApp = useNuxtApp();\n    const pageRef = ref();\n    const forkRoute = inject(PageRouteSymbol, null);\n    let previousPageKey;\n    expose({ pageRef });\n    const _layoutMeta = inject(LayoutMetaSymbol, null);\n    let vnode;\n    const done = nuxtApp.deferHydration();\n    if (import.meta.client && nuxtApp.isHydrating) {\n      const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", done);\n      useRouter().beforeEach(removeErrorHook);\n    }\n    if (import.meta.client && props.pageKey) {\n      watch(() => props.pageKey, (next, prev) => {\n        if (next !== prev) {\n          nuxtApp.callHook(\"page:loading:start\");\n        }\n      });\n    }\n    if (import.meta.dev) {\n      nuxtApp._isNuxtPageUsed = true;\n    }\n    let pageLoadingEndHookAlreadyCalled = false;\n    if (import.meta.client) {\n      const unsub = useRouter().beforeResolve(() => {\n        pageLoadingEndHookAlreadyCalled = false;\n      });\n      onBeforeUnmount(() => {\n        unsub();\n      });\n    }\n    return () => {\n      return h(RouterView, { name: props.name, route: props.route, ...attrs }, {\n        default: import.meta.server ? (routeProps) => {\n          return h(Suspense, { suspensible: true }, {\n            default() {\n              return h(RouteProvider, {\n                vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,\n                route: routeProps.route,\n                vnodeRef: pageRef\n              });\n            }\n          });\n        } : (routeProps) => {\n          const isRenderingNewRouteInOldFork = haveParentRoutesRendered(forkRoute, routeProps.route, routeProps.Component);\n          const hasSameChildren = forkRoute && forkRoute.matched.length === routeProps.route.matched.length;\n          if (!routeProps.Component) {\n            if (vnode && !hasSameChildren) {\n              return vnode;\n            }\n            done();\n            return;\n          }\n          if (vnode && _layoutMeta && !_layoutMeta.isCurrent(routeProps.route)) {\n            return vnode;\n          }\n          if (isRenderingNewRouteInOldFork && forkRoute && (!_layoutMeta || _layoutMeta?.isCurrent(forkRoute))) {\n            if (hasSameChildren) {\n              return vnode;\n            }\n            return null;\n          }\n          const key = generateRouteKey(routeProps, props.pageKey);\n          const willRenderAnotherChild = hasChildrenRoutes(forkRoute, routeProps.route, routeProps.Component);\n          if (!nuxtApp.isHydrating && previousPageKey === key && !willRenderAnotherChild) {\n            nextTick(() => {\n              pageLoadingEndHookAlreadyCalled = true;\n              nuxtApp.callHook(\"page:loading:end\");\n            });\n          }\n          previousPageKey = key;\n          const hasTransition = !!(props.transition ?? routeProps.route.meta.pageTransition ?? defaultPageTransition);\n          const transitionProps = hasTransition && _mergeTransitionProps([\n            props.transition,\n            routeProps.route.meta.pageTransition,\n            defaultPageTransition,\n            {\n              onAfterLeave() {\n                delete nuxtApp._runningTransition;\n                nuxtApp.callHook(\"page:transition:finish\", routeProps.Component);\n              }\n            }\n          ]);\n          const keepaliveConfig = props.keepalive ?? routeProps.route.meta.keepalive ?? defaultKeepaliveConfig;\n          vnode = _wrapInTransition(\n            hasTransition && transitionProps,\n            wrapInKeepAlive(\n              keepaliveConfig,\n              h(Suspense, {\n                suspensible: true,\n                onPending: () => {\n                  if (hasTransition) {\n                    nuxtApp._runningTransition = true;\n                  }\n                  nuxtApp.callHook(\"page:start\", routeProps.Component);\n                },\n                onResolve: () => {\n                  nextTick(() => nuxtApp.callHook(\"page:finish\", routeProps.Component).then(() => {\n                    if (!pageLoadingEndHookAlreadyCalled && !willRenderAnotherChild) {\n                      pageLoadingEndHookAlreadyCalled = true;\n                      return nuxtApp.callHook(\"page:loading:end\");\n                    }\n                  }).finally(done));\n                }\n              }, {\n                default: () => {\n                  const routeProviderProps = {\n                    key: key || void 0,\n                    vnode: slots.default ? normalizeSlot(slots.default, routeProps) : routeProps.Component,\n                    route: routeProps.route,\n                    renderKey: key || void 0,\n                    trackRootNodes: hasTransition,\n                    vnodeRef: pageRef\n                  };\n                  if (!keepaliveConfig) {\n                    return h(RouteProvider, routeProviderProps);\n                  }\n                  const routerComponentType = routeProps.Component.type;\n                  const routeProviderKey = import.meta.dev ? routerComponentType.name || routerComponentType.__name : routerComponentType;\n                  let PageRouteProvider = _routeProviders.get(routeProviderKey);\n                  if (!PageRouteProvider) {\n                    PageRouteProvider = defineRouteProvider(routerComponentType.name || routerComponentType.__name);\n                    _routeProviders.set(routeProviderKey, PageRouteProvider);\n                  }\n                  return h(PageRouteProvider, routeProviderProps);\n                }\n              })\n            )\n          ).default();\n          return vnode;\n        }\n      });\n    };\n  }\n});\nfunction _mergeTransitionProps(routeProps) {\n  const _props = routeProps.filter(Boolean).map((prop) => ({\n    ...prop,\n    onAfterLeave: prop.onAfterLeave ? toArray(prop.onAfterLeave) : void 0\n  }));\n  return defu(..._props);\n}\nfunction haveParentRoutesRendered(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  if (!index || index === -1) {\n    return false;\n  }\n  return newRoute.matched.slice(0, index).some(\n    (c, i) => c.components?.default !== fork.matched[i]?.components?.default\n  ) || Component && generateRouteKey({ route: newRoute, Component }) !== generateRouteKey({ route: fork, Component });\n}\nfunction hasChildrenRoutes(fork, newRoute, Component) {\n  if (!fork) {\n    return false;\n  }\n  const index = newRoute.matched.findIndex((m) => m.components?.default === Component?.type);\n  return index < newRoute.matched.length - 1;\n}\nfunction normalizeSlot(slot, data) {\n  const slotContent = slot(data);\n  return slotContent.length === 1 ? h(slotContent[0]) : h(Fragment, void 0, slotContent);\n}\n","<template>\n  <NuxtLayout>\n    <NuxtPage />\n  </NuxtLayout>\n</template>\n","<template>\n  <ErrorTemplate v-bind=\"{ statusCode, statusMessage, description, stack }\" />\n</template>\n\n<script setup>\nimport { defineAsyncComponent } from \"vue\";\nconst props = defineProps({\n  error: Object\n});\nconst _error = props.error;\nconst stacktrace = _error.stack ? _error.stack.split(\"\\n\").splice(1).map((line) => {\n  const text = line.replace(\"webpack:/\", \"\").replace(\".vue\", \".js\").trim();\n  return {\n    text,\n    internal: line.includes(\"node_modules\") && !line.includes(\".cache\") || line.includes(\"internal\") || line.includes(\"new Promise\")\n  };\n}).map((i) => `<span class=\"stack${i.internal ? \" internal\" : \"\"}\">${i.text}</span>`).join(\"\\n\") : \"\";\nconst statusCode = Number(_error.statusCode || 500);\nconst is404 = statusCode === 404;\nconst statusMessage = _error.statusMessage ?? (is404 ? \"Page Not Found\" : \"Internal Server Error\");\nconst description = _error.message || _error.toString();\nconst stack = import.meta.dev && !is404 ? _error.description || `<pre>${stacktrace}</pre>` : void 0;\nconst _Error404 = defineAsyncComponent(() => import(\"./error-404.vue\"));\nconst _Error = import.meta.dev ? defineAsyncComponent(() => import(\"./error-dev.vue\")) : defineAsyncComponent(() => import(\"./error-500.vue\"));\nconst ErrorTemplate = is404 ? _Error404 : _Error;\n</script>\n","<template>\n  <Suspense @resolve=\"onResolve\">\n    <div v-if=\"abortRender\" />\n    <ErrorComponent\n      v-else-if=\"error\"\n      :error=\"error\"\n    />\n    <IslandRenderer\n      v-else-if=\"islandContext\"\n      :context=\"islandContext\"\n    />\n    <component\n      :is=\"SingleRenderer\"\n      v-else-if=\"SingleRenderer\"\n    />\n    <AppComponent v-else />\n  </Suspense>\n</template>\n\n<script setup>\nimport { defineAsyncComponent, onErrorCaptured, onServerPrefetch, provide } from \"vue\";\nimport { useNuxtApp } from \"../nuxt\";\nimport { isNuxtError, showError, useError } from \"../composables/error\";\nimport { useRoute, useRouter } from \"../composables/router\";\nimport { PageRouteSymbol } from \"../components/injections\";\nimport AppComponent from \"#build/app-component.mjs\";\nimport ErrorComponent from \"#build/error-component.mjs\";\nimport { componentIslands } from \"#build/nuxt.config.mjs\";\nconst IslandRenderer = import.meta.server && componentIslands ? defineAsyncComponent(() => import(\"./island-renderer\").then((r) => r.default || r)) : () => null;\nconst nuxtApp = useNuxtApp();\nconst onResolve = nuxtApp.deferHydration();\nif (import.meta.client && nuxtApp.isHydrating) {\n  const removeErrorHook = nuxtApp.hooks.hookOnce(\"app:error\", onResolve);\n  useRouter().beforeEach(removeErrorHook);\n}\nconst url = import.meta.server ? nuxtApp.ssrContext.url : window.location.pathname;\nconst SingleRenderer = import.meta.test && import.meta.dev && import.meta.server && url.startsWith(\"/__nuxt_component_test__/\") && defineAsyncComponent(() => import(\"#build/test-component-wrapper.mjs\").then((r) => r.default(import.meta.server ? url : window.location.href)));\nprovide(PageRouteSymbol, useRoute());\nconst results = nuxtApp.hooks.callHookWith((hooks) => hooks.map((hook) => hook()), \"vue:setup\");\nif (import.meta.dev && results && results.some((i) => i && \"then\" in i)) {\n  console.error(\"[nuxt] Error in `vue:setup`. Callbacks must be synchronous.\");\n}\nconst error = useError();\nconst abortRender = import.meta.server && error.value && !nuxtApp.ssrContext.error;\nconst BOT_RE = /bot\\b|chrome-lighthouse|facebookexternalhit|google\\b/i;\nonErrorCaptured((err, target, info) => {\n  nuxtApp.hooks.callHook(\"vue:error\", err, target, info).catch((hookError) => console.error(\"[nuxt] Error in `vue:error` hook\", hookError));\n  if (import.meta.client && BOT_RE.test(navigator.userAgent)) {\n    nuxtApp.hooks.callHook(\"app:error\", err);\n    console.error(`[nuxt] Not rendering error page for bot with user agent \\`${navigator.userAgent}\\`:`, err);\n    return false;\n  }\n  if (import.meta.server || isNuxtError(err) && (err.fatal || err.unhandled)) {\n    const p = nuxtApp.runWithContext(() => showError(err));\n    onServerPrefetch(() => p);\n    return false;\n  }\n});\nconst islandContext = import.meta.server && nuxtApp.ssrContext.islandContext;\n</script>\n","import { createApp, createSSRApp, nextTick } from \"vue\";\nimport \"#build/fetch.mjs\";\nimport \"#build/global-polyfills.mjs\";\nimport { applyPlugins, createNuxtApp } from \"./nuxt.js\";\nimport { createError } from \"./composables/error.js\";\nimport \"#build/css\";\nimport plugins from \"#build/plugins\";\nimport RootComponent from \"#build/root-component.mjs\";\nimport { appId, appSpaLoaderAttrs, multiApp, spaLoadingTemplateOutside, vueAppRootContainer } from \"#build/nuxt.config.mjs\";\nlet entry;\nif (import.meta.server) {\n  entry = async function createNuxtAppServer(ssrContext) {\n    const vueApp = createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp, ssrContext });\n    try {\n      await applyPlugins(nuxt, plugins);\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n    } catch (error) {\n      await nuxt.hooks.callHook(\"app:error\", error);\n      nuxt.payload.error ||= createError(error);\n    }\n    if (ssrContext?._renderResponse) {\n      throw new Error(\"skipping render\");\n    }\n    return vueApp;\n  };\n}\nif (import.meta.client) {\n  if (import.meta.dev && import.meta.webpackHot) {\n    import.meta.webpackHot.accept();\n  }\n  let vueAppPromise;\n  entry = async function initApp() {\n    if (vueAppPromise) {\n      return vueAppPromise;\n    }\n    const isSSR = Boolean(\n      (multiApp ? window.__NUXT__?.[appId] : window.__NUXT__)?.serverRendered ?? (multiApp ? document.querySelector(`[data-nuxt-data=\"${appId}\"]`) : document.getElementById(\"__NUXT_DATA__\"))?.dataset.ssr === \"true\"\n    );\n    const vueApp = isSSR ? createSSRApp(RootComponent) : createApp(RootComponent);\n    const nuxt = createNuxtApp({ vueApp });\n    async function handleVueError(error) {\n      await nuxt.callHook(\"app:error\", error);\n      nuxt.payload.error ||= createError(error);\n    }\n    vueApp.config.errorHandler = handleVueError;\n    nuxt.hook(\"app:suspense:resolve\", () => {\n      if (vueApp.config.errorHandler === handleVueError) {\n        vueApp.config.errorHandler = void 0;\n      }\n    });\n    if (spaLoadingTemplateOutside && !isSSR && appSpaLoaderAttrs.id) {\n      nuxt.hook(\"app:suspense:resolve\", () => {\n        document.getElementById(appSpaLoaderAttrs.id)?.remove();\n      });\n    }\n    try {\n      await applyPlugins(nuxt, plugins);\n    } catch (err) {\n      handleVueError(err);\n    }\n    try {\n      await nuxt.hooks.callHook(\"app:created\", vueApp);\n      await nuxt.hooks.callHook(\"app:beforeMount\", vueApp);\n      vueApp.mount(vueAppRootContainer);\n      await nuxt.hooks.callHook(\"app:mounted\", vueApp);\n      await nextTick();\n    } catch (err) {\n      handleVueError(err);\n    }\n    return vueApp;\n  };\n  vueAppPromise = entry().catch((error) => {\n    console.error(\"Error while mounting app:\", error);\n    throw error;\n  });\n}\nexport default (ssrContext) => entry(ssrContext);\n"],"version":3}