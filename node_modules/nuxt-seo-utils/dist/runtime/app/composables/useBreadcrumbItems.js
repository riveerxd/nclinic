import {
  defineBreadcrumb,
  useI18n,
  useSchemaOrg
} from "#imports";
import { useSiteConfig } from "#site-config/app/composables/useSiteConfig";
import { createSitePathResolver } from "#site-config/app/composables/utils";
import { defu } from "defu";
import { fixSlashes } from "nuxt-site-config/urls";
import { useRouter } from "nuxt/app";
import { withoutTrailingSlash } from "ufo";
import { computed, toValue } from "vue";
import { pathBreadcrumbSegments } from "../../shared/breadcrumbs.js";
function withoutQuery(path) {
  return path.split("?")[0];
}
function titleCase(s) {
  return s.replaceAll("-", " ").replace(/\w\S*/g, (w) => w.charAt(0).toUpperCase() + w.substr(1).toLowerCase());
}
export function useBreadcrumbItems(options = {}) {
  const router = useRouter();
  const i18n = useI18n();
  const siteResolver = createSitePathResolver({
    canonical: true,
    absolute: true
  });
  const siteConfig = useSiteConfig();
  const items = computed(() => {
    let rootNode = "/";
    if (i18n) {
      if (i18n.strategy === "prefix" || i18n.strategy !== "no_prefix" && toValue(i18n.defaultLocale) !== toValue(i18n.locale))
        rootNode = `/${toValue(i18n.locale)}`;
    }
    const current = withoutQuery(withoutTrailingSlash(toValue(options.path || router.currentRoute.value?.path) || rootNode));
    const overrides = toValue(options.overrides) || [];
    const segments = pathBreadcrumbSegments(current, rootNode).map((path, index) => {
      let item = {
        to: path
      };
      if (typeof overrides[index] !== "undefined") {
        if (overrides[index] === false)
          return false;
        item = defu(overrides[index], item);
      }
      return item;
    });
    if (options.prepend)
      segments.unshift(...toValue(options.prepend));
    if (options.append)
      segments.push(...toValue(options.append));
    return segments.filter(Boolean).map((item) => {
      let fallbackLabel = titleCase(String((item.to || "").split("/").pop()));
      let fallbackAriaLabel = "";
      const route = router.resolve(item.to)?.matched?.[0];
      if (route) {
        const routeMeta = route?.meta || {};
        if (routeMeta.breadcrumb) {
          item = {
            ...item,
            ...routeMeta.breadcrumb
          };
        }
        const routeName = String(route.name).split("___")[0];
        if (routeName === "index") {
          fallbackLabel = "Home";
        }
        fallbackLabel = routeMeta.breadcrumbLabel || routeMeta.breadcrumbTitle || routeMeta.title || fallbackLabel;
        fallbackLabel = i18n.t(`breadcrumb.items.${routeName}.label`, fallbackLabel, { missingWarn: true });
        fallbackAriaLabel = i18n.t(`breadcrumb.items.${routeName}.ariaLabel`, fallbackAriaLabel, { missingWarn: false });
      }
      item.label = item.label || fallbackLabel;
      item.ariaLabel = item.ariaLabel || fallbackAriaLabel || item.label;
      item.current = item.current || item.to === current;
      if (toValue(options.hideCurrent) && item.current)
        return false;
      return item;
    }).map((m) => {
      if (m && m.to) {
        m.to = fixSlashes(siteConfig.trailingSlash, m.to);
        if (m.to === rootNode && toValue(options.hideRoot))
          return false;
      }
      return m;
    }).filter(Boolean);
  });
  const schemaOrgEnabled = typeof options.schemaOrg === "undefined" ? true : options.schemaOrg;
  if ((import.meta.dev || import.meta.server) && schemaOrgEnabled) {
    useSchemaOrg([
      defineBreadcrumb({
        id: `#${options.id || "breadcrumb"}`,
        itemListElement: computed(() => items.value.map((item) => ({
          name: item.label || item.ariaLabel,
          item: item.to ? siteResolver(item.to) : void 0
        })))
      })
    ]);
  }
  return items;
}
